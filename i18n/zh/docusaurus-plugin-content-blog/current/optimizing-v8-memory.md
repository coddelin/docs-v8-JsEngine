---
title: &apos;优化 V8 的内存消耗&apos;
author: &apos;V8 内存管理工程师 Ulan Degenbaev、Michael Lippautz、Hannes Payer 和 Toon Verwaest&apos;
avatars:
  - &apos;ulan-degenbaev&apos;
  - &apos;michael-lippautz&apos;
  - &apos;hannes-payer&apos;
date: 2016-10-07 13:33:37
tags:
  - 内存
  - 基准测试
description: &apos;V8 团队分析并显著减少了多个网站的内存占用，这些网站被认为是现代 Web 开发模式的代表。&apos;
---
内存消耗是 JavaScript 虚拟机性能权衡空间中的一个重要维度。在过去的几个月中，V8 团队分析并显著减少了多个网站的内存占用，这些网站被认为是现代 Web 开发模式的代表。在这篇博客中，我们展示了分析中使用的工作负载和工具，概述了垃圾回收器的内存优化，并展示了我们如何减少 V8 的解析器及其编译器的内存消耗。

<!--truncate-->
## 基准测试

为了对 V8 进行分析并发现对大多数用户具有影响的优化，定义可重复、有意义并模拟常见现实场景的工作负载是至关重要的。一个用于执行此任务的优秀工具是 [Telemetry](https://catapult.gsrc.io/telemetry)，这是一个性能测试框架，可在 Chrome 中运行脚本化的网站交互并记录所有服务器响应以便在我们的测试环境中以可预测的方式回放这些交互。我们选择了一组受欢迎的新闻、社交和媒体网站，并为它们定义了以下常见用户交互：

用于浏览新闻和社交网站的工作负载：

1. 打开一个热门的新闻或社交网站，例如 Hacker News。
1. 点击第一个链接。
1. 等到新的网站加载完成。
1. 向下滚动几页。
1. 点击返回按钮。
1. 点击原始网站上的下一个链接，然后重复步骤 3-6 几次。

用于浏览媒体网站的工作负载：

1. 打开一个热门媒体网站上的内容，例如 YouTube 上的视频。
1. 观看该内容几秒钟。
1. 点击下一个内容，然后重复步骤 2–3 几次。

一旦工作流程被捕捉下来，就可以根据需要多次在 Chrome 的开发版本上回放，例如每次有新的 V8 版本发布时。在回放过程中，V8 的内存使用量会以固定时间间隔采样，以获得有意义的平均值。基准测试可以在[这里](https://cs.chromium.org/chromium/src/tools/perf/page_sets/system_health/browsing_stories.py?q=browsing+news&sq=package:chromium&dr=CS&l=11)找到。

## 内存可视化

优化性能时面临的主要挑战之一是清晰了解内部 VM 状态，以跟踪进度或权衡潜在的折衷。对于内存消耗优化，这意味着在执行时准确跟踪 V8 的内存消耗。必须跟踪两类内存：分配给 V8 管理堆的内存和分配给 C++ 堆的内存。**V8 堆统计**功能是开发人员用来深入了解这两类内存的机制之一。当运行 Chrome（版本 54 或更新）或 `d8` 命令行界面时指定 `--trace-gc-object-stats` 标志，V8 会将与内存相关的统计信息输出到控制台。我们构建了一个自定义工具，[V8 堆可视化工具](https://mlippautz.github.io/v8-heap-stats/)，用于可视化这些输出。此工具显示了管理堆和 C++ 堆的基于时间线的视图。它还详细列出了某些内部数据类型的内存使用，并为这些类型中的每种提供基于大小的直方图。

在我们的优化过程中，一个常见的工作流程是选择时间线视图中占据堆很大部分的实例类型，如图 1 所示。一旦选择了实例类型，工具会显示该类型的使用分布。在此示例中，我们选择了 V8 的内部 FixedArray 数据结构，这是一种非类型化的类似向量的容器，在 VM 的各种地方被广泛使用。图 2 显示了一个典型的 FixedArray 分布，在这里我们可以看到大部分内存可归因于某个特定的 FixedArray 使用场景。在这种情况下，FixedArrays 被用作稀疏 JavaScript 数组（我们称之为 DICTIONARY\_ELEMENTS）的存储支持。通过这些信息，可以回到实际代码，从而验证这种分布是否是预期行为，或者是否存在优化的机会。我们使用该工具识别了一些内部类型的不高效之处。

![图 1：管理堆和堆外内存的时间线视图](/_img/optimizing-v8-memory/timeline-view.png)

![图2：实例类型的分布](/_img/optimizing-v8-memory/distribution.png)

图3显示了C++堆内存的消耗，主要由区域内存（zone memory）组成（V8用于短时间的临时内存区域；下面将更详细地讨论）。由于V8解析器和编译器最广泛地使用区域内存，这些峰值对应于解析和编译事件。一种良好行为的执行仅包括峰值，表明内存在不再需要时立即被释放。相反，平台期（即更长时间的高内存消耗）表明仍有优化空间。

![图3：区域内存](/_img/optimizing-v8-memory/zone-memory.png)

早期采用者也可以尝试将其集成到[Chrome的跟踪基础架构](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool)中。因此，您需要运行带有`--track-gc-object-stats`的最新Chrome Canary版本，并[捕获一个跟踪](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/recording-tracing-runs#TOC-Capture-a-trace-on-Chrome-desktop)，包括类别`v8.gc_stats`。然后，数据将显示在`V8.GC_Object_Stats`事件中。

## JavaScript堆内存缩减

在垃圾回收吞吐量、延迟和内存消耗之间存在内在的权衡。例如，垃圾回收延迟（导致用户可见的卡顿）可以通过使用更多内存来减少，以避免频繁的垃圾回收调用。而对于低内存的移动设备，例如内存低于512 MB的设备，优先考虑延迟和吞吐量而不是内存消耗可能会导致内存不足崩溃和Android上的标签页挂起。

为了更好地平衡这些低内存移动设备的权衡，我们引入了一种特殊的内存缩减模式，该模式调整了几个垃圾回收启发式方法，以降低JavaScript垃圾回收堆内存的使用。

1. 在完整垃圾回收结束时，V8的堆增长策略根据存活对象的数量加上一些额外松弛空间来确定下一次垃圾回收的时间。在内存缩减模式下，V8使用较少的松弛空间，从而由于更频繁的垃圾回收导致较低的内存使用量。
1. 此外，该估算值被视为一个硬性限制，强制尚未完成的增量标记工作在主要的垃圾回收暂停阶段完成。通常，在非内存缩减模式下，尚未完成的增量标记工作可能会超过该限制，以自由触发主要垃圾回收暂停，仅在标记完成时触发。
1. 通过执行更激进的内存压缩进一步减少内存碎片化。

图4描述了自Chrome 53以来低内存设备上的一些改进。最明显的是，移动版《纽约时报》基准测试的平均V8堆内存消耗减少了约66%。总体而言，我们在这一组基准测试中观察到平均V8堆大小减少了50%。

![图4：自Chrome 53以来低内存设备上的V8堆内存减少](/_img/optimizing-v8-memory/heap-memory-reduction.png)

最近引入的另一项优化不仅减少了低内存设备上的内存，同时也优化了配置更高的移动设备和桌面设备。将V8堆页面大小从1 MB减少到512 kB，在没有许多存活对象时减少了内存占用，同时整体内存碎片化降低了高达2倍。它还允许V8执行更多的压缩工作，因为更小的工作块允许内存压缩线程以并行方式完成更多工作。

## 区域内存缩减

除了JavaScript堆之外，V8还使用堆外内存进行内部虚拟机操作。最大的内存块通过称为_zone_的内存区域分配。区域是一种基于区域的内存分配器，支持快速分配和批量释放，在销毁区域时一次性释放所有区域分配的内存。区域在V8的解析器和编译器中广泛使用。

Chrome 55中的主要改进之一来自于减少背景解析期间的内存使用。背景解析允许V8在页面加载时解析脚本。内存可视化工具帮助我们发现，背景解析器会在代码已经编译后长时间保留整个区域。通过在编译后立即释放区域，我们显著减少了区域的生命周期，从而降低了平均和峰值内存使用量。

另一个改进是通过更好地在解析器生成的_抽象语法树_节点中打包字段实现的。之前我们依赖C++编译器在可能的情况下将字段打包在一起，例如两个布尔值只需要两个位，应该位于一个字中或前一个字未使用的部分中。C++编译器并不总是找到最压缩的打包方式，因此我们改为手动打包位。这不仅减少了峰值内存使用，还提高了解析器和编译器的性能。

图5展示了自Chrome 54以来的峰值区域内存改进，测量的网页平均减少了约40%。

![图5：自Chrome 54以来桌面端V8峰值区域内存减少](/_img/optimizing-v8-memory/peak-zone-memory-reduction.png)

在未来几个月中，我们将继续致力于减少V8的内存占用。我们计划为解析器进行更多区域内存优化，并将重点放在内存范围为512 MB到1 GB的设备上。

**更新：** 上述所有改进使得Chrome 55在_低内存设备_上的总体内存消耗相比于Chrome 53减少最多35%。其他设备类别仅受益于区域内存的改进。
