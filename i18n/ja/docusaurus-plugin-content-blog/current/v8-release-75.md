---
title: 'V8リリース v7.5'
author: 'Dan Elphick, 廃止された機能の恐怖'
avatars:
  - 'dan-elphick'
date: 2019-05-16 15:00:00
tags:
  - リリース
description: 'V8 v7.5は、WebAssemblyコンパイルアーティファクトの暗黙的キャッシュ、大量メモリ操作、JavaScriptの数値セパレータなど、多くの機能を備えています！'
tweet: '1129073370623086593'
---
6週間ごとに、V8の新しいブランチを[リリースプロセス](/docs/release-process)の一環として作成します。各バージョンは、Chromeのベータ版マイルストーン直前にV8のGitマスターからブランチされます。本日、最新のブランチである[V8バージョン7.5](https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/7.5)を発表できることを嬉しく思います。このバージョンは、数週間後にChrome 75 Stableと連動してリリースされるまでベータ版です。V8 v7.5は、開発者向けのあらゆる機能が盛り込まれています。本投稿では、リリースに先立ち、いくつかの注目点を紹介します。

<!--truncate-->
## WebAssembly

### 暗黙的キャッシュ

Chrome 75で、WebAssemblyコンパイルアーティファクトの暗黙的なキャッシュの展開を予定しています。これにより、同じページを2回目に訪れる際には、すでに見たWebAssemblyモジュールを再コンパイルする必要がなくなります。代わりに、それらはキャッシュから読み込まれます。これは[ChromiumのJavaScriptコードキャッシュ](/blog/code-caching-for-devs)に似ています。

V8埋め込みで同様の機能を使用したい場合は、Chromiumの実装を参考にしてください。

### 大量メモリ操作

[大量メモリ提案](https://github.com/webassembly/bulk-memory-operations)は、メモリまたはテーブルの大きな領域を更新するための新しいWebAssembly命令を追加します。

`memory.copy`は、領域が重複していても、ある領域から別の領域へデータをコピーします（Cの`memmove`のように）。`memory.fill`は、指定されたバイトで領域を埋めます（Cの`memset`のように）。`memory.copy`と同様に、`table.copy`は1つのテーブル領域から別の領域にコピーします。これも領域が重複していても動作します。

```wasm
;; 1000番地から500バイトを0番地にコピー
(memory.copy (i32.const 0) (i32.const 1000) (i32.const 500))

;; 100番地から1000バイトを値`123`で埋める
(memory.fill (i32.const 100) (i32.const 123) (i32.const 1000))

;; 5番地から15番地にテーブル要素10個をコピー
(table.copy (i32.const 15) (i32.const 5) (i32.const 10))
```

提案は、一定領域を線形メモリまたはテーブルにコピーする方法も提供します。そのためにはまず、「パッシブ」セグメントを定義する必要があります。「アクティブ」セグメントとは異なり、これらのセグメントはモジュール生成時に初期化されることはありません。代わりに、`memory.init`や`table.init`命令を使用して、メモリやテーブル領域にコピーすることができます。

```wasm
;; パッシブデータセグメントを定義
(data $hello passive "Hello WebAssembly")

;; 10番地のメモリに"Hello"をコピー
(memory.init (i32.const 10) (i32.const 0) (i32.const 5))

;; 1000番地のメモリに"WebAssembly"をコピー
(memory.init (i32.const 1000) (i32.const 6) (i32.const 11))
```

## JavaScriptでの数値セパレータ

大きな数値リテラルは、多くの繰り返し数字がある場合、目で素早く解析するのが困難です。

```js
1000000000000
   1019436871.42
```

読みやすさを向上させるために、[新しいJavaScript言語機能](/features/numeric-separators)は、数値リテラルでアンダースコアをセパレータとして有効にします。これにより、以下のように桁ごとに数字をグループ化できます:

```js
1_000_000_000_000
    1_019_436_871.42
```

これで、最初の数字が1兆であり、2番目の数字が約10億のオーダーであることを簡単に把握できます。

数値セパレータの他の例や追加情報については、[解説](/features/numeric-separators)を参照してください。

## パフォーマンス

### ネットワークからのスクリプトストリーミング

Chrome 75では、V8はネットワークからストリーミングパーサーにスクリプトを直接ストリーミングできるようになり、Chromeのメインスレッドを待つ必要がありません。

以前のChromeバージョンではストリーミング解析とコンパイルがありましたが、ネットワークからのスクリプトソースデータは、ストリーマーに転送される前に常にChromeのメインスレッドに到達する必要がありました。この理由は歴史的なものです。このため、多くの場合、ストリーミングパーサーは、すでにネットワークから届いたデータを待つことになる一方で、それはメインスレッド（HTML解析、レイアウト、他のJavaScript実行など）が原因でまだストリーミングタスクに転送されていませんでした。

![Chrome 74以前では、バックグラウンド解析タスクが停止している](/_img/v8-release-75/before.jpg)

Chrome 75では、ネットワークの「データパイプ」を直接V8に接続することで、ネットワークデータを直接ストリーミング解析中に読み込むことが可能になり、メインスレッドへの依存がなくなりました。

![Chrome 75以降、メインスレッドの活動によるバックグラウンド解析タスクのブロックがなくなった](/_img/v8-release-75/after.jpg)

これにより、ストリーミングコンパイルが早期に完了するようになり、ストリーミングコンパイルを使用するページの読み込み時間が改善されるほか、並行する（ただし停止している）ストリーミング解析タスクの数が減り、メモリ消費が削減されます。

## V8 API

`git log branch-heads/7.4..branch-heads/7.5 include/v8.h` を使用してAPIの変更点を確認してください。

[有効なV8チェックアウト](/docs/source-code#using-git)を持つ開発者は、`git checkout -b 7.5 -t branch-heads/7.5` を使用してV8 v7.5の新機能を試すことができます。または、[Chromeのベータチャンネル](https://www.google.com/chrome/browser/beta.html)に登録し、自分自身で新機能を試すこともできます。
