---
title: 'Static Roots: コンパイル時に定数アドレスを持つオブジェクト'
author: 'Olivier Flückiger'
avatars:
  - olivier-flueckiger
date: 2024-02-05
tags:
  - JavaScript
description: "Static Rootsは、特定のJSオブジェクトのアドレスをコンパイル時の定数にします。"
tweet: ''
---

あなたは`undefined`、`true`、その他のコアJavaScriptオブジェクトがどこから来るのか考えたことがありますか？これらのオブジェクトは、任意のユーザー定義オブジェクトの基本単位であり、最初に存在している必要があります。V8はこれらを固定不変なルートと呼び、それらは専用のヒープ – 読み取り専用ヒープに住んでいます。これらは頻繁に使用されるため、迅速なアクセスが重要です。そしてコンパイル時にメモリアドレスを正しく予測するほど迅速な方法はないでしょうか？

<!--truncate-->
例として、非常に一般的な`IsUndefined` [API関数](https://source.chromium.org/chromium/chromium/src/+/main:v8/include/v8-value.h?q=symbol:%5Cbv8::Value::IsUndefined%5Cb%20case:yes)を考えてみましょう。参照するために`undefined`オブジェクトのアドレスを調べる代わりに、たとえばオブジェクトのポインタの末尾が`0x61`で終わっているかどうかを確認することで、それが未定義であることを知ることができるのならどうでしょう。これがV8の*static roots*機能が達成することです。この投稿では、これを実現するために乗り越えた障壁を探ります。この機能はChrome 111で導入され、VM全体にわたるパフォーマンス向上をもたらし、特にC++コードやビルトイン関数の速度を向上させました。

## 読み取り専用ヒープのブートストラップ

読み取り専用オブジェクトを作成するのに少し時間がかかるため、V8はそれらをコンパイル時に作成します。V8をコンパイルするために、最初に最小限のプロト-V8バイナリ`mksnapshot`がコンパイルされます。これにより、共有読み取り専用オブジェクトとビルトイン関数のネイティブコードが作成され、スナップショットに書き込まれます。その後、実際のV8バイナリがコンパイルされ、スナップショットと共にバンドルされます。V8を開始するには、スナップショットをメモリにロードするだけで、その内容をすぐに使用できます。以下の図は、スタンドアロン`d8`バイナリの簡略化されたビルドプロセスを示したものです。

![](/_img/static-roots/static-roots1.svg)

`d8`が起動すると、すべての読み取り専用オブジェクトはメモリの固定された場所に配置され、移動することはありません。コードをJITする際には、たとえば`undefined`をそのアドレスで直接参照することができます。ただし、スナップショットを構築する際やlibv8のC++をコンパイルするときには、アドレスはまだ不明です。これは、ビルド時に未知の2つの要因によります。一つ目は読み取り専用ヒープのバイナリレイアウトであり、二つ目はその読み取り専用ヒープがメモリ空間のどこに配置されるかです。

## アドレスを予測する方法は？

V8は[ポインタ圧縮](https://v8.dev/blog/pointer-compression)を使用します。完全な64ビットアドレスの代わりに、オブジェクトをメモリ4GB領域の32ビットオフセットで参照します。プロパティのロードや比較など多くの操作において、そのケージ内の32ビットオフセットだけでオブジェクトを一意に識別できます。そのため、メモリ空間内で読み取り専用ヒープがどこに配置されるか知らないという問題は実際には問題ではありません。読み取り専用ヒープをポインタ圧縮ケージの開始位置に配置するだけで、それに既知の場所を与えます。たとえばV8ヒープ内のすべてのオブジェクトのうち、`undefined`は常に最小圧縮アドレスを持ち、0x61バイトから始まっています。これにより、任意のJSオブジェクトの完全なアドレスの下位32ビットが0x61である場合、それが`undefined`であることがわかります。

これはすでに便利ですが、スナップショットやlibv8でこのアドレスを使用したいと思っています – 見かけ上循環した問題です。しかし、`mksnapshot`がビットで完全に同一な読み取り専用ヒープを決定的に作成することを保証すれば、これらのアドレスをビルド間で再利用できます。libv8自体でそれらを使用するためには、基本的にV8を2回ビルドします:

![](/_img/static-roots/static-roots2.svg)

最初の段階で`mksnapshot`を呼び出し、生成された成果物はすべての読み取り専用ヒープ内オブジェクトのケージベースからの[アドレス](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/roots/static-roots.h)が含まれたファイルだけです。ビルドの第2段階ではlibv8を再コンパイルし、フラグが設定されることで、`undefined`を参照する場合には常に`cage_base + StaticRoot::kUndefined`を使うことを保証します。もちろん、静的オフセット`undefined`はstatic-roots.hファイルに定義されています。多くのケースでは、これによってlibv8を作成しているC++コンパイラや`mksnapshot`内のビルトインコンパイラがより効率的なコードを作成できるようになり、代替案として常にグローバルなルートオブジェクトの配列からアドレスをロードする必要がなくなります。圧縮済みアドレス`undefined`が`0x61`にハードコードされた`d8`バイナリを作成することになります。

まあ、倫理的にはこれが動作の仕方ですが、実際にはV8を一度しかビルドしません – 誰もそんなことをする時間はありません。生成されたstatic-roots.hファイルはソースリポジトリにキャッシュされ、読み取り専用ヒープのレイアウトを変更した場合にのみ再作成する必要があります。

## その他の応用

実用性の話をすると、静的ルートはさらなる最適化を可能にします。例えば、共通のオブジェクトをまとめることで、アドレス範囲チェックとしていくつかの操作を実装することができました。例えば、すべての文字列マップ（つまり、異なる文字列型のレイアウトを記述する[hidden-class](https://v8.dev/docs/hidden-classes)メタオブジェクト）は互いに隣接しているため、オブジェクトが文字列である場合、そのマップの圧縮アドレスが`0xdd`から`0x49d`の間にある必要があります。また、truthyオブジェクトはそのアドレスが少なくとも`0xc1`以上でなければなりません。

V8におけるJITコードの性能だけがすべてではありません。このプロジェクトが示したように、C++コードへの比較的小さな変更が大きな影響を与えることもあります。例えばSpeedometer 2は、V8 APIとV8とその埋め込みエンベッダーとの相互作用を試験するベンチマークですが、静的ルートのおかげでM1 CPU上でスコアが約1%向上しました。
