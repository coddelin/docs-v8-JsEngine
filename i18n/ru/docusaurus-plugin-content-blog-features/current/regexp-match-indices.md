---
title: "Индексы совпадений RegExp"
author: "Майя Армянова ([@Zmayski](https://twitter.com/Zmayski)), регулярно выражая новые возможности"
avatars: 
  - "maya-armyanova"
date: 2019-12-17
tags: 
  - ECMAScript
  - Node.js 16
description: "Индексы совпадений RegExp предоставляют `начало` и `конец` диапазонов каждой группы захвата."
tweet: "1206970814400270338"
---
JavaScript теперь оснащён новым улучшением для регулярных выражений, называемым «индексы совпадений». Представьте, что вы хотите найти недопустимые имена переменных в JavaScript коде, совпадающие с зарезервированными словами, и вывести каретку и «подчеркивание» под именем переменной, например:

<!--truncate-->
```js
const function = foo;
      ^------- Недопустимое имя переменной
```

В приведённом выше примере `function` — зарезервированное слово и не может быть использовано как имя переменной. Для этого мы можем написать следующую функцию:

```js
function displayError(text, message) {
  const re = /\b(continue|function|break|for|if)\b/d;
  const match = text.match(re);
  // Индекс `1` соответствует первой группе захвата.
  const [start, end] = match.indices[1];
  const error = ' '.repeat(start) + // Настройка позиции каретки.
    '^' +
    '-'.repeat(end - start - 1) +   // Добавление подчеркивания.
    ' ' + message;                 // Добавление сообщения.
  console.log(text);
  console.log(error);
}

const code = 'const function = foo;'; // ошибочный код
displayError(code, 'Недопустимое имя переменной');
```

:::note
**Примечание:** Для простоты приведённый выше пример содержит только несколько JavaScript [зарезервированных слов](https://mathiasbynens.be/notes/reserved-keywords).
:::

Коротко говоря, новый массив `indices` хранит начальные и конечные позиции каждой совпадающей группы захвата. Этот новый массив доступен, если исходное регулярное выражение использует флаг `/d` для всех встроенных методов, создающих объекты совпадений регулярного выражения, включая `RegExp#exec`, `String#match` и [`String#matchAll`](https://v8.dev/features/string-matchall).

Читайте дальше, если вам интересно, как это работает более подробно.

## Мотивация

Перейдём к более сложному примеру и подумаем, как решить задачу разбора языка программирования (например, то, что делает [компилятор TypeScript](https://github.com/microsoft/TypeScript/tree/master/src/compiler)) — сначала разделить исходный код на токены, затем придать этим токенам синтаксическую структуру. Если пользователь написал какой-либо синтаксически некорректный код, вы захотите показать ему полезную ошибку, желательно указав место, где впервые был обнаружен проблемный код. Например, учитывая следующий фрагмент кода:

```js
let foo = 42;
// какой-то другой код
let foo = 1337;
```

Мы хотели бы показать программисту ошибку следующего вида:

```js
let foo = 1337;
    ^
SyntaxError: Идентификатор 'foo' уже был объявлен
```

Чтобы достичь этого, нам потребуется несколько строительных блоков, первый из которых — распознавание идентификаторов TypeScript. Затем мы сосредоточимся на точном месте, где произошла ошибка. Рассмотрим следующий пример, используя регулярное выражение, чтобы определить, является ли строка допустимым идентификатором:

```js
function isIdentifier(name) {
  const re = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
  return re.exec(name) !== null;
}
```

:::note
**Примечание:** Реальный парсер может использовать недавно введённые [экранирования свойств в регулярных выражениях](https://github.com/tc39/proposal-regexp-unicode-property-escapes#other-examples) и использовать следующее регулярное выражение для сопоставления всех допустимых имён идентификаторов ECMAScript:

```js
const re = /^[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}]*$/u;
```

Для простоты мы будем использовать наше предыдущее регулярное выражение, которое соответствует только латинским символам, числам и символам подчёркивания.
:::

Если мы столкнёмся с ошибкой в объявлении переменной, как в примере выше, и захотим указать точное место пользователю, мы можем расширить регулярное выражение из предыдущего примера и использовать подобную функцию:

```js
function getDeclarationPosition(source) {
  const re = /(let|const|var)\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/;
  const match = re.exec(source);
  if (!match) return -1;
  return match.index;
}
```

Можно использовать свойство `index` объекта совпадения, возвращаемого `RegExp.prototype.exec`, который возвращает начальную позицию всего совпадения. Однако для случаев использования, описанных выше, часто требуется использовать (возможно, несколько) группы захвата. До недавнего времени JavaScript не предоставлял индексы, где начинаются и заканчиваются подстроки, соответствующие группам захвата.

## Объяснение индексов совпадений RegExp

Идеально, если мы хотим указать ошибку в месте имени переменной, а не ключевого слова `let`/`const` (как в приведённом выше примере). Но для этого нам нужно найти позицию группы захвата с индексом `2`. (Индекс `1` относится к группе захвата `(let|const|var)`, а `0` относится ко всему совпадению.)

Как уже упоминалось выше, [новая функция JavaScript](https://github.com/tc39/proposal-regexp-match-indices) добавляет свойство `indices` к результату (массиву подстрок) метода `RegExp.prototype.exec()`. Давайте улучшим наш пример выше, чтобы использовать это новое свойство:

```js
function getVariablePosition(source) {
  // Обратите внимание на флаг `d`, который активирует `match.indices`
  const re = /(let|const|var)\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/d;
  const match = re.exec(source);
  if (!match) return undefined;
  return match.indices[2];
}
getVariablePosition('let foo');
// → [4, 7]
```

Этот пример возвращает массив `[4, 7]`, который представляет `[start, end)` позицию совпавшей подстроки из группы с индексом `2`. На основе этой информации наш компилятор теперь может вывести желаемую ошибку.

## Дополнительные возможности

Объект `indices` также содержит свойство `groups`, которое может быть индексировано по именам [именованных захватывающих групп](https://mathiasbynens.be/notes/es-regexp-proposals#named-capture-groups). Используя это, функцию выше можно переписать так:

```js
function getVariablePosition(source) {
  const re = /(?<keyword>let|const|var)\s+(?<id>[a-zA-Z_$][0-9a-zA-Z_$]*)/d;
  const match = re.exec(source);
  if (!match) return -1;
  return match.indices.groups.id;
}
getVariablePosition('let foo');
```

## Поддержка индексов совпадений RegExp

<feature-support chrome="90 https://bugs.chromium.org/p/v8/issues/detail?id=9548"
                 firefox="no https://bugzilla.mozilla.org/show_bug.cgi?id=1519483"
                 safari="no https://bugs.webkit.org/show_bug.cgi?id=202475"
                 nodejs="16"
                 babel="no"></feature-support>
