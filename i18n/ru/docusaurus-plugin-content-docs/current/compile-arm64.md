---
title: &apos;Компиляция на Arm64 Linux&apos;
description: &apos;Советы и хитрости для сборки V8 непосредственно на Arm64 Linux&apos;
---
Если вы ознакомились с инструкциями о том, как [загрузить](/docs/source-code) и [собрать](/docs/build-gn) V8 на устройстве, которое не является x86 или Apple Silicon Mac, возможно, вы столкнулись с некоторыми трудностями из-за того, что система сборки загружает собственные двоичные файлы, которые затем не могут быть выполнены. Однако, несмотря на то, что использование Arm64 Linux для работы с V8 __официально не поддерживается__, преодоление этих препятствий достаточно просто.

## Обход `vpython`

`fetch v8`, `gclient sync` и другие команды из `depot_tools` используют оболочку для python под названием "vpython". Если вы видите ошибки, связанные с этим, вы можете определить следующую переменную, чтобы использовать установленную на системе версию python:

```bash
export VPYTHON_BYPASS="manually managed python not supported by chrome operations"
```

## Совместимый двоичный файл `ninja`

Первое, что нужно сделать, — это убедиться, что мы используем собственный двоичный файл для `ninja`, который мы используем вместо файла, находящегося в `depot_tools`. Простым способом сделать это является настройка вашего PATH следующим образом при установке `depot_tools`:

```bash
export PATH=$PATH:/path/to/depot_tools
```

Таким образом, вы сможете использовать установленный в вашей системе `ninja`, если он, скорее всего, доступен. Однако, если его нет, вы можете [собрать его из исходного кода](https://github.com/ninja-build/ninja#building-ninja-itself).

## Компиляция clang

По умолчанию V8 захочет использовать свою собственную версию clang, которая может не работать на вашем устройстве. Вы можете настроить аргументы GN, чтобы [использовать системный clang или GCC](#system_clang_gcc), однако, возможно, вы захотите использовать тот же clang, что и в исходном коде, поскольку это будет наиболее поддерживаемая версия.

Вы можете собрать его локально непосредственно из загруженного V8:

```bash
./tools/clang/scripts/build.py --without-android --without-fuchsia \
                               --host-cc=gcc --host-cxx=g++ \
                               --gcc-toolchain=/usr \
                               --use-system-cmake --disable-asserts
```

## Ручная настройка аргументов GN

Скрипты автоматизации могут не работать по умолчанию, вместо этого вам нужно будет вручную настроить аргументы GN, следуя [инструкции](/docs/build-gn#gn). Вы можете получить обычные конфигурации "release", "optdebug" и "debug" с помощью следующих аргументов:

- `release`

```bash
is_debug=false
```

- `optdebug`

```bash
is_debug=true
v8_enable_backtrace=true
v8_enable_slow_dchecks=true
```

- `debug`

```bash
is_debug=true
v8_enable_backtrace=true
v8_enable_slow_dchecks=true
v8_optimized_debug=false
```

## Использование системного clang или GCC

Сборка с GCC — это просто вопрос отключения компиляции с clang:

```bash
is_clang=false
```

Обратите внимание, что по умолчанию V8 будет связываться с помощью `lld`, что требует последней версии GCC. Вы можете использовать `use_lld=false`, чтобы переключиться на компоновщик gold, или дополнительно использовать `use_gold=false`, чтобы использовать компоновщик `ld`.

Если вы хотите использовать clang, установленный в вашей системе, например в `/usr`, вы можете использовать следующие аргументы:

```bash
clang_base_path="/usr"
clang_use_chrome_plugins=false
```

Однако, учитывая, что версия clang вашей системы может быть не так хорошо поддерживаемой, скорее всего вы столкнетесь с предупреждениями, такими как неизвестные флаги компилятора. В этом случае полезно прекратить обработку предупреждений как ошибок с помощью:

```bash
treat_warnings_as_errors=false
```
