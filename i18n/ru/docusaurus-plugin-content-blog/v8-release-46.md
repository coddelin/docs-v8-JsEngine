---
title: "Релиз V8 версии v4.6"
author: "команда V8"
date: "2015-08-28 13:33:37"
tags: 
  - релиз
description: "V8 v4.6 с уменьшенной задержкой и поддержкой новых возможностей языка ES2015."
---
Примерно каждые шесть недель мы создаем новую ветку V8 в рамках нашего [процесса релиза](https://v8.dev/docs/release-process). Каждая версия ответвляется от основной ветки Git V8 немедленно перед ответвлением Chrome для бета-версии Chrome. Сегодня мы рады объявить о создании нашей новой ветки, [версии V8 4.6](https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/4.6), которая будет в бета-версии до ее выпуска в стабильной версии Chrome 46. V8 4.6 включает множество нововведений для разработчиков, и мы хотим представить некоторые из основных моментов в ожидании релиза через несколько недель.

<!--truncate-->
## Улучшенная поддержка ECMAScript 2015 (ES6)

V8 v4.6 добавляет поддержку нескольких возможностей [ECMAScript 2015 (ES6)](https://www.ecma-international.org/ecma-262/6.0/).

### Оператор распространения

[Оператор распространения](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) делает работу с массивами гораздо удобнее. Например, он позволяет заменить императивный код при простом объединении массивов.

```js
// Объединение массивов
// Код без оператора распространения
const inner = [3, 4];
const merged = [0, 1, 2].concat(inner, [5]);

// Код с оператором распространения
const inner = [3, 4];
const merged = [0, 1, 2, ...inner, 5];
```

Еще один хороший способ использования оператора распространения — это замена `apply`:

```js
// Параметры функции, хранящиеся в массиве
// Код без оператора распространения
function myFunction(a, b, c) {
  console.log(a);
  console.log(b);
  console.log(c);
}
const argsInArray = ['Hi ', 'Spread ', 'operator!'];
myFunction.apply(null, argsInArray);

// Код с оператором распространения
function myFunction (a,b,c) {
  console.log(a);
  console.log(b);
  console.log(c);
}

const argsInArray = ['Hi ', 'Spread ', 'operator!'];
myFunction(...argsInArray);
```

### `new.target`

[new.target](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target) — одна из функций ES6, предназначенная для упрощения работы с классами. На самом деле это неявный параметр каждой функции. Если функция вызывается с ключевым словом new, то параметр содержит ссылку на вызванную функцию. Если new не используется, то параметр равен undefined.

На практике это означает, что вы можете использовать new.target, чтобы определить, была ли функция вызвана нормально или как конструктор с использованием ключевого слова new.

```js
function myFunction() {
  if (new.target === undefined) {
    throw 'Попробуйте вызвать с использованием new.';
  }
  console.log('Работает!');
}

// Ошибка:
myFunction();

// Работает:
const a = new myFunction();
```

Когда используются классы ES6 и наследование, new.target внутри конструктора супер-класса привязывается к производному конструктору, который был вызван с new. Это дает сверх-классам доступ к прототипу производного класса во время создания объекта.

## Уменьшение задержки

[Задержки](https://en.wiktionary.org/wiki/jank#Noun) могут быть весьма раздражающими, особенно при игре. Часто они становятся еще хуже в многопользовательских играх. [oortonline.gl](http://oortonline.gl/) — это тест WebGL, проверяющий возможности современных браузеров через рендеринг сложной 3D-сцены с эффектами частиц и современными шейдерами. Команда V8 отправилась в поход, чтобы увеличить производительность Chrome в этих условиях. Мы еще не закончили, но плоды наших усилий уже заметны. Chrome 46 показывает невероятный прогресс в производительности oortonline.gl, который вы можете увидеть сами ниже.

Некоторые из оптимизаций включают:

- [Улучшения производительности TypedArray](https://code.google.com/p/v8/issues/detail?id=3996)
    - TypedArray активно используется в движках рендеринга, таких как Turbulenz (движок oortonline.gl). Например, движки часто создают typed arrays (такие как Float32Array) в JavaScript и передают их в WebGL после преобразований.
    - Ключевым моментом была оптимизация взаимодействия между встроенной частью (Blink) и V8.
- [Улучшения производительности при передаче TypedArray и другой памяти из V8 в Blink](https://code.google.com/p/chromium/issues/detail?id=515795)
    - Нет необходимости создавать дополнительные дескрипторы (которые также отслеживаются V8) для typed arrays при их передаче в WebGL как часть односторонней коммуникации.
    - При достижении пределов внешней памяти (выделяемой Blink) мы теперь начинаем инкрементный сбор мусора вместо полного.
- [Планирование сбора мусора в режиме ожидания](/blog/free-garbage-collection)
    - Операции по сбору мусора планируются в периоды простоя на основном потоке, что освобождает компоновщик и приводит к более плавному рендерингу.
- [Разрешено параллельное сборка мусора для всего старого поколения собираемой кучи](https://code.google.com/p/chromium/issues/detail?id=507211)
    - Освобождение неиспользуемых блоков памяти выполняется на дополнительных потоках параллельно с основным потоком, что значительно сокращает время основного паузы при сборке мусора.

Хорошая новость в том, что все изменения, связанные с oortonline.gl, являются общими улучшениями, которые потенциально влияют на всех пользователей приложений, сильно использующих WebGL.

## V8 API

Пожалуйста, ознакомьтесь с нашим [резюме изменений API](https://docs.google.com/document/d/1g8JFi8T_oAE_7uAri7Njtig7fKaPDfotU6huOa1alds/edit). Этот документ регулярно обновляется через несколько недель после каждого основного выпуска.

Разработчики с [активной копией исходного кода V8](https://v8.dev/docs/source-code#using-git) могут использовать `git checkout -b 4.6 -t branch-heads/4.6`, чтобы поэкспериментировать с новыми функциями в V8 v4.6. В качестве альтернативы вы можете [подписаться на бета-канал Chrome](https://www.google.com/chrome/browser/beta.html) и сами скоро попробовать новые функции.
