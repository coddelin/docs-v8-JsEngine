---
title: "Релиз V8 версии 8.4"
author: "Камилло Бруни, наслаждающийся свежими булевыми значениями"
avatars:
 - "camillo-bruni"
date: 2020-06-30
tags:
 - выпуск
description: "V8 версия 8.4 включает слабые ссылки и улучшенную производительность WebAssembly."
tweet: "1277983235641761795"
---
Каждые шесть недель мы создаем новую ветку V8 в рамках нашего [процесса релиза](https://v8.dev/docs/release-process). Каждая версия создается из основной ветки Git V8 незадолго до достижения Chrome Beta. Сегодня мы рады объявить о нашей новой ветке [V8 версия 8.4](https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/8.4), которая будет находиться в бета-тестировании до ее выпуска вместе со стабильной версией Chrome 84 через несколько недель. В версии V8 v8.4 полно полезных функций для разработчиков. В этом посте представлен предварительный обзор некоторых ключевых моментов перед выпуском.

<!--truncate-->
## WebAssembly

### Ускоренное время запуска

Базовый компилятор WebAssembly ([Liftoff](https://v8.dev/blog/liftoff)) теперь поддерживает [атомарные операции](https://github.com/WebAssembly/threads) и [массовые операции с памятью](https://github.com/WebAssembly/bulk-memory-operations). Это значит, что даже если вы используете эти недавние изменения спецификации, вы получите чрезвычайно быстрое время запуска.

### Улучшенная отладка

В рамках постоянных усилий по улучшению отладки в WebAssembly мы теперь можем инспектировать любой кадр WebAssembly, который находится в памяти, каждый раз, когда вы останавливаете выполнение или достигаете точки останова.
Это стало возможным благодаря повторному использованию [Liftoff](https://v8.dev/blog/liftoff) для отладки. Раньше весь код с точками останова или при пошаговом выполнении нужно было интерпретировать, что значительно замедляло выполнение (зачастую примерно в 100 раз). С Liftoff вы теряете всего около трети производительности, но при этом можете пошагово проходить весь код и исследовать его в любое время.

### Испытание SIMD

Предложение SIMD позволяет WebAssembly использовать широко доступные аппаратные векторные инструкции для ускорения вычислительно интенсивных задач. V8 имеет [поддержку](https://v8.dev/features/simd) для [предложения WebAssembly SIMD](https://github.com/WebAssembly/simd). Чтобы включить это в Chrome, используйте флаг `chrome://flags/#enable-webassembly-simd` или зарегистрируйтесь для [испытания в Origin](https://developers.chrome.com/origintrials/#/view_trial/-4708513410415853567). [Испытания Origin](https://github.com/GoogleChrome/OriginTrials/blob/gh-pages/developer-guide.md) позволяют разработчикам экспериментировать с функцией перед ее стандартизацией и предоставлять ценную обратную связь. После того, как Origin включен в испытание, пользователи автоматически получают доступ к функции на период действия испытания без необходимости обновлять флаги Chrome.

## JavaScript

### Слабые ссылки и финализаторы

:::note
**Внимание!** Слабые ссылки и финализаторы — это продвинутые функции! Они зависят от поведения сборщика мусора. Сборка мусора является недетерминированной и может не происходить вовсе.
:::

JavaScript — это язык со сборкой мусора, что означает, что память, занимаемая объектами, которые больше недостижимы для программы, может автоматически освобождаться, когда запускается сборщик мусора. За исключением ссылок в `WeakMap` и `WeakSet`, все ссылки в JavaScript являются сильными и предотвращают сборку мусора для объекта. Например:

```js
const globalRef = {
  callback() { console.log('foo'); }
};
// Пока globalRef доступен через глобальную область видимости,
// ни он, ни функция в его свойстве callback не будут собраны сборщиком мусора.
```

Теперь программисты на JavaScript могут слабо удерживать объекты через функцию `WeakRef`. Объекты, на которые имеются слабые ссылки, не препятствуют их сборке мусора, если они не имеют сильных ссылок.

```js
const globalWeakRef = new WeakRef({
  callback() { console.log('foo'); }
});

(async function() {
  globalWeakRef.deref().callback();
  // Выводит “foo” в консоль. globalWeakRef гарантированно будет жив
  // в первый цикл обработки событий после его создания.

  await new Promise((resolve, reject) => {
    setTimeout(() => { resolve('foo'); }, 42);
  });
  // Ожидание одного цикла обработки событий.

  globalWeakRef.deref()?.callback();
  // Объект внутри globalWeakRef может быть собран сборщиком мусора
  // после первого цикла, так как он больше недостижим.
})();
```

Сопутствующей функцией к `WeakRef` является `FinalizationRegistry`, которая позволяет программистам регистрировать обратные вызовы, вызываемые после сбора мусора объекта. Например, следующая программа может вывести `42` в консоль после того, как недостижимый объект в IIFE будет собран.

```js
const registry = new FinalizationRegistry((heldValue) => {
  console.log(heldValue);
});

(function () {
  const garbage = {};
  registry.register(garbage, 42);
  // Второй аргумент — это “удерживаемое” значение, которое передается
  // в финализатор, когда первый аргумент собирается сборщиком мусора.
})();
```

Финализаторы планируются для выполнения в цикле событий и никогда не прерывают синхронное выполнение JavaScript.

Это сложные и мощные функции, и, с большой вероятностью, вашей программе они не понадобятся. Пожалуйста, ознакомьтесь с нашим [объяснением](https://v8.dev/features/weak-references), чтобы узнать больше о них!

### Приватные методы и аксессоры

Приватные поля, которые появились в версии 7.4, были дополнены поддержкой приватных методов и аксессоров. Синтаксически имена приватных методов и аксессоров начинаются с `#`, как и у приватных полей. Вот краткий пример синтаксиса.

```js
class Component {
  #privateMethod() {
    console.log("Я доступен только внутри Component!");
  }
  get #privateAccessor() { return 42; }
  set #privateAccessor(x) { }
}
```

Приватные методы и аксессоры имеют те же правила области видимости и семантику, что и приватные поля. Пожалуйста, ознакомьтесь с нашим [объяснением](https://v8.dev/features/class-fields), чтобы узнать больше.

Спасибо [Igalia](https://twitter.com/igalia) за вклад в реализацию!

## API V8

Пожалуйста, используйте `git log branch-heads/8.3..branch-heads/8.4 include/v8.h`, чтобы получить список изменений в API.

Разработчики, имеющие активную копию V8, могут использовать `git checkout -b 8.4 -t branch-heads/8.4`, чтобы поэкспериментировать с новыми функциями в V8 версии 8.4. Или вы можете [подписаться на бета-канал Chrome](https://www.google.com/chrome/browser/beta.html) и вскоре попробовать новые функции самостоятельно.
