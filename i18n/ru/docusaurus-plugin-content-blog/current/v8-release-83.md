---
title: &apos;Релиз V8 v8.3&apos;
author: &apos;[Виктор Гомес](https://twitter.com/VictorBFG), безопасно работает из дома&apos;
avatars:
 - &apos;victor-gomes&apos;
date: 2020-05-04
tags:
 - release
description: &apos;V8 v8.3 включает более быстрые ArrayBuffer&apos;ы, большие объемы памяти Wasm и устаревшие API.&apos;
tweet: &apos;1257333120115847171&apos;
---

Каждые шесть недель мы создаем новую ветвь V8 в рамках нашего [процесса выпуска](https://v8.dev/docs/release-process). Каждая версия ветвится от мастер-ветки Git сразу перед выходом Chrome Beta. Сегодня мы рады объявить о нашей новой ветви, [V8 версии 8.3](https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/8.3), которая находится в бета-версии до релиза совместно со стабильной версией Chrome 83 через несколько недель. V8 v8.3 наполнена множеством новшеств для разработчиков. В этом посте представлен обзор некоторых ключевых изменений.

<!--truncate-->
## Производительность

### Более быстрая обработка `ArrayBuffer` в сборщике мусора

Места хранения для `ArrayBuffer` выделяются вне кучи V8 с использованием `ArrayBuffer::Allocator`, предоставленного окружением. Эти места хранения необходимо освободить, когда объект `ArrayBuffer` удаляется сборщиком мусора. V8 v8.3 включает новый механизм отслеживания `ArrayBuffer` и их мест хранения, который позволяет сборщику мусора запускать итерацию и освобождение мест хранения одновременно с приложением. Более подробную информацию можно найти в [этом проектировочном документе](https://docs.google.com/document/d/1-ZrLdlFX1nXT3z-FAgLbKal1gI8Auiaya_My-a0UJ28/edit#heading=h.gfz6mi5p212e). Это уменьшило общее время пауз сборщика мусора на 50% для задач, активно использующих `ArrayBuffer`.

### Большие объемы памяти Wasm

В соответствии с обновлением [спецификации WebAssembly](https://webassembly.github.io/spec/js-api/index.html#limits), V8 v8.3 теперь позволяет модулям запрашивать объемы памяти размером до 4 ГБ, что открывает возможности для более объемных сценариев использования на платформах с поддержкой V8. Помните, что такой объем памяти может быть не всегда доступен на системе пользователя; мы рекомендуем создавать области памяти меньших размеров, увеличивать их по мере необходимости и корректно обрабатывать ошибки при попытке увеличить объем.

## Исправления

### Запись в объекты с типизированными массивами в цепочке прототипов

Согласно спецификации JavaScript, при записи значения по заданному ключу необходимо проверить цепочку прототипов, чтобы узнать, существует ли ключ уже на прототипе. В большинстве случаев эти ключи отсутствуют в цепочке прототипов, и поэтому V8 устанавливает быстрые обработчики поиска, чтобы избежать таких обходов цепочек прототипов, если это безопасно.

Однако недавно мы обнаружили особый случай, когда V8 неправильно устанавливал такой быстрый обработчик поиска, что приводило к некорректному поведению. Когда `TypedArray` находятся в цепочке прототипов, все записи в ключи, которые выходят за пределы `TypedArray`, должны игнорироваться. Например, в следующем случае `v[2]` не должен добавлять свойство в `v`, а последующие чтения должны возвращать undefined.

```js
v = {};
v.__proto__ = new Int32Array(1);
v[2] = 123;
return v[2]; // Должен вернуть undefined
```

Быстрые обработчики поиска V8 не обрабатывали этот случай, и вместо этого мы возвращали `123` в приведенном выше примере. V8 v8.3 исправляет эту проблему, не используя быстрые обработчики поиска, когда `TypedArray` находятся в цепочке прототипов. Учитывая, что это не распространенный случай, мы не наблюдали какого-либо снижения производительности в наших тестах.

## API V8

### Устаревшие экспериментальные API WeakRefs и FinalizationRegistry

Следующие экспериментальные API, связанные с WeakRefs, устарели:

- `v8::FinalizationGroup`
- `v8::Isolate::SetHostCleanupFinalizationGroupCallback`

`FinalizationRegistry` (переименован из `FinalizationGroup`) является частью [предложения по слабым ссылкам в JavaScript](https://v8.dev/features/weak-references) и предоставляет способ для программистов JavaScript регистрировать финализаторы. Эти API предоставляли возможность окружению планировать и выполнять задачи очистки `FinalizationRegistry`, где вызывались зарегистрированные финализаторы; они устарели, так как больше не нужны. Задачи очистки `FinalizationRegistry` теперь автоматически планируются V8 с использованием планировщика задач переднего плана, предоставляемого окружением через `v8::Platform`, и не требуют дополнительного кода со стороны окружения.

### Другие изменения в API

Используйте `git log branch-heads/8.1..branch-heads/8.3 include/v8.h`, чтобы получить список изменений в API.

Разработчики с активным клоном V8 могут использовать `git checkout -b 8.3 -t branch-heads/8.3`, чтобы использовать новые возможности V8 v8.3. Кроме того, вы можете [подписаться на бета-канал Chrome](https://www.google.com/chrome/browser/beta.html) и вскоре попробовать новые функции самостоятельно.
