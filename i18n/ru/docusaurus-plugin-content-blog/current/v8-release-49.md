---
title: &apos;Релиз V8 версии 4.9&apos;
author: &apos;команда V8&apos;
date: 2016-01-26 13:33:37
tags:
  - релиз
description: &apos;V8 версии 4.9 предлагает улучшенную реализацию `Math.random` и добавляет поддержку нескольких новых функций языка из ES2015.&apos;
---
Примерно каждые шесть недель мы создаём новую ветку V8 в рамках нашего [процесса релизов](/docs/release-process). Каждая версия разветвляется от основной ветки Git V8 незадолго до разветвления Chrome для создания Chrome Beta. Сегодня мы рады объявить о нашей новой ветке, [V8 версия 4.9](https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/4.9), которая будет находиться в бета-версии до её выпуска совместно с Chrome 49 Stable. V8 4.9 наполнен различными нововведениями для разработчиков, поэтому мы хотим дать вам предварительный обзор некоторых из них, ожидая релиза через несколько недель.

<!--truncate-->
## 91% поддержки ECMAScript 2015 (ES6)

В версии V8 4.9 мы внедрили больше функций ES2015 JavaScript, чем в любом из предыдущих релизов, достигнув 91% завершения, согласно [таблице совместимости Kangax](https://kangax.github.io/compat-table/es6/) (по состоянию на 26 января). Теперь V8 поддерживает дескруктуризацию, параметры по умолчанию, объекты Proxy и API Reflect. Релиз 4.9 также делает конструкции блочного уровня, такие как `class` и `let`, доступными вне строгого режима и добавляет поддержку флага sticky для регулярных выражений и настраиваемый вывод `Object.prototype.toString`.

### Деструктуризация

Объявления переменных, параметры и присваивания теперь поддерживают [деструктуризацию](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) объектов и массивов с использованием шаблонов. Например:

```js
const o = {a: [1, 2, 3], b: {p: 4}, c: {q: 5}};
let {a: [x, y], b: {p}, c, d} = o;              // x=1, y=2, p=4, c={q: 5}
[x, y] = [y, x];                                // x=2, y=1
function f({a, b}) { return [a, b]; }
f({a: 4});                                      // [4, undefined]
```

Шаблоны массивов могут содержать остаточные шаблоны, которым присваивается оставшаяся часть массива:

```js
const [x, y, ...r] = [1, 2, 3, 4];              // x=1, y=2, r=[3,4]
```

Кроме того, элементам шаблона можно задавать значения по умолчанию, которые используются в случае отсутствия соответствующего свойства:

```js
const {a: x, b: y = x} = {a: 4};                // x=4, y=4
// или…
const [x, y = 0, z = 0] = [1, 2];               // x=1, y=2, z=0
```

Деструктуризация может быть использована для более компактного доступа к данным из объектов и массивов.

### Proxy и Reflect

После многих лет разработки V8 теперь поддерживает полную реализацию [объектов Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy), соответствующую спецификации ES2015. Proxy являются мощным механизмом для виртуализации объектов и функций с помощью набора предоставленных разработчиком хуков для настройки доступа к свойствам. Помимо виртуализации объектов, Proxy могут быть использованы для перехвата операций, добавления проверки значений свойств, упрощения отладки и профилирования, а также для реализации продвинутых абстракций, таких как [мембраны](http://tvcutsem.github.io/js-membranes/).

Чтобы использовать Proxy для объекта, необходимо создать объект-хэндлер, определяющий различные ловушки, и применить его к целевому объекту, который будет виртуализирован:

```js
const target = {};
const handler = {
  get(target, name=&apos;мир&apos;) {
    return `Привет, ${name}!`;
  }
};

const foo = new Proxy(target, handler);
foo.bar;
// → &apos;Привет, bar!&apos;
```

Объект Proxy сопровождается модулем Reflect, который предоставляет подходящие значения по умолчанию для всех ловушек Proxy:

```js
const debugMe = new Proxy({}, {
  get(target, name, receiver) {
    console.log(`Отладка: метод get вызван для поля: ${name}`);
    return Reflect.get(target, name, receiver);
  },
  set(target, name, value, receiver) {
    console.log(`Отладка: метод set вызван для поля: ${name}, и значения: ${value}`);
    return Reflect.set(target, name, value, receiver);
  }
});

debugMe.name = &apos;Джон Доу&apos;;
// Отладка: метод set вызван для поля: name, и значения: Джон Доу
const title = `Г-н ${debugMe.name}`; // → &apos;Г-н Джон Доу&apos;
// Отладка: метод get вызван для поля: name
```

Для получения дополнительной информации об использовании Proxy и Reflect API см. раздел примеров на [странице MDN о Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Examples).

### Параметры по умолчанию

В ES5 и более ранних версиях для работы с необязательными параметрами в определениях функций требовалось писать вспомогательный код для проверки неопределённости параметров:

```js
function sublist(list, start, end) {
  if (typeof start === &apos;undefined&apos;) start = 0;
  if (typeof end === &apos;undefined&apos;) end = list.length;
  ...
}
```

ES2015 теперь позволяет задавать [значения по умолчанию](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters) для параметров функций, что делает определения функций более ясными и лаконичными:

```js
function sublist(list, start = 0, end = list.length) { … }
sublist([1, 2, 3], 1);
// sublist([1, 2, 3], 1, 3)
```

Параметры по умолчанию, конечно, можно комбинировать с деструктуризацией:

```js
function vector([x, y, z] = []) { … }
```

### Классы и лексические объявления в нестрогом режиме

V8 поддерживает лексические объявления (`let`, `const`, локальные функции в блоках) и классы с версий 4.1 и 4.2 соответственно, но до настоящего времени для их использования требовался строгий режим. Начиная с версии 4.9, все эти возможности теперь включены и вне строгого режима в соответствии со спецификацией ES2015. Это значительно облегчает прототипирование в консоли DevTools, хотя мы рекомендуем разработчикам использовать строгий режим для нового кода.

### Регулярные выражения

Теперь V8 поддерживает новый [sticky flag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky) для регулярных выражений. Sticky-флаг управляет тем, начнется ли поиск в строках с начала строки (обычный режим) или с свойства `lastIndex` (sticky-режим). Это поведение полезно для эффективного анализа произвольно длинных входных строк с помощью множества различных регулярных выражений. Чтобы включить sticky-поиск, добавьте флаг `y` к регулярному выражению: (например, `const regex = /foo/y;`).

### Пользовательский вывод `Object.prototype.toString`

С помощью `Symbol.toStringTag` пользовательские типы теперь могут возвращать индивидуализированный вывод при использовании `Object.prototype.toString` (либо напрямую, либо в результате строки приведения):

```js
class Custom {
  get [Symbol.toStringTag]() {
    return &apos;Custom&apos;;
  }
}
Object.prototype.toString.call(new Custom);
// → &apos;[object Custom]&apos;
String(new Custom);
// → &apos;[object Custom]&apos;
```

## Улучшенный `Math.random()`

V8 v4.9 включает улучшение реализации `Math.random()`. [Как было объявлено в прошлом месяце](/blog/math-random), мы сменили алгоритм PRNG в V8 на [xorshift128+](http://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf), чтобы обеспечить более качественную псевдослучайную генерацию чисел.

## API V8

Пожалуйста, ознакомьтесь с нашим [резюме изменений API](https://docs.google.com/document/d/1g8JFi8T_oAE_7uAri7Njtig7fKaPDfotU6huOa1alds/edit). Этот документ регулярно обновляется через несколько недель после каждого основного выпуска.

Разработчики с [активным исходным кодом V8](https://v8.dev/docs/source-code#using-git) могут использовать `git checkout -b 4.9 -t branch-heads/4.9`, чтобы опробовать новые функции в V8 версии 4.9. В качестве альтернативы вы можете подписаться на [Beta канал Chrome](https://www.google.com/chrome/browser/beta.html) и скоро попробовать новые функции самостоятельно.
