---
title: 'V8 релиз v6.5'
author: 'команда V8'
date: 2018-02-01 13:33:37
tags:
  - релиз
description: 'V8 v6.5 добавляет поддержку потоковой компиляции WebAssembly и включает новый режим «недоверенного кода».'
tweet: '959174292406640640'
---
Каждые шесть недель мы создаем новую ветку V8 в рамках нашего [процесса выпуска](/docs/release-process). Каждая версия отделяется от Git master V8 непосредственно перед этапом бета-версии Chrome. Сегодня мы рады объявить о нашей новой ветке, [V8 версии 6.5](https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/6.5), которая находится в стадии бета-тестирования до ее выпуска в координации с Chrome 65 Stable через несколько недель. V8 v6.5 наполнен различными полезными инструментами для разработчиков. В этом посте представлены основные моменты в предвкушении выпуска.

<!--truncate-->
## Режим недоверенного кода

В ответ на последнюю спекулятивную атаку через побочные каналы, названную Spectre, V8 ввел [режим недоверенного кода](/docs/untrusted-code-mitigations). Если вы используете V8, рассмотрите возможность использования этого режима, если ваше приложение обрабатывает пользовательский, ненадежный код. Обратите внимание, что этот режим включен по умолчанию, включая Chrome.

## Потоковая компиляция для WebAssembly

API WebAssembly предоставляет специальную функцию для поддержки [потоковой компиляции](https://developers.google.com/web/updates/2018/04/loading-wasm) в сочетании с `fetch()` API:

```js
const module = await WebAssembly.compileStreaming(fetch('foo.wasm'));
```

Этот API доступен начиная с V8 v6.1 и Chrome 61, хотя начальная реализация не использовала потоковую компиляцию. Однако с V8 v6.5 и Chrome 65 мы используем этот API, компилируя модули WebAssembly уже во время загрузки байтов модуля. Как только мы загружаем все байты одной функции, мы передаем функцию на задний план для компиляции.

Наши замеры показывают, что с этим API компиляция WebAssembly в Chrome 65 может поддерживать скорость загрузки до 50 Мбит/с на высокопроизводительных машинах. Это означает, что если вы загружаете код WebAssembly со скоростью 50 Мбит/с, его компиляция завершится одновременно с завершением загрузки.

На графике ниже мы измеряем время, необходимое для загрузки и компиляции модуля WebAssembly объемом 67 МБ и около 190 000 функций. Мы проводим измерения при скорости загрузки 25 Мбит/с, 50 Мбит/с и 100 Мбит/с.

![](/_img/v8-release-65/wasm-streaming-compilation.svg)

Когда время загрузки длиннее времени компиляции модуля WebAssembly, например на графике выше со скоростью 25 Мбит/с и 50 Мбит/с, то `WebAssembly.compileStreaming()` завершает компиляцию почти сразу после загрузки последних байтов.

Когда время загрузки короче времени компиляции, то `WebAssembly.compileStreaming()` занимает примерно столько же времени, сколько требуется для компиляции модуля WebAssembly без предварительной загрузки модуля.

## Скорость

Мы продолжаем работать над расширением быстрого пути встроенных функций JavaScript, добавляя механизм обнаружения и предотвращения разрушительной ситуации, называемой «цикл деоптимизации». Это происходит, когда ваш оптимизированный код деоптимизируется, и _нет способа понять, что пошло не так_. В таких сценариях TurboFan просто продолжает пытаться оптимизировать, наконец сдаваясь после примерно 30 попыток. Это случилось бы, если бы вы изменили форму массива в функции обратного вызова любой из встроенных функций для работы с массивами второго порядка. Например, изменение `length` массива — в V8 v6.5 мы фиксируем, когда это происходит, и прекращаем встроенную оптимизацию функции массива на этом месте при будущих попытках оптимизации.

Мы также расширили быстрый путь, встроив многие функции, которые ранее исключались из-за побочного эффекта между загрузкой вызываемой функции и самим вызовом, например вызовом функции. Вызов функции `String.prototype.indexOf` получил [повышение производительности в 10 раз](https://bugs.chromium.org/p/v8/issues/detail?id=6270).

В V8 v6.4 мы внедрили поддержку для встроенных функций `Array.prototype.forEach`, `Array.prototype.map` и `Array.prototype.filter`. В V8 v6.5 мы добавили поддержку для встроенности:

- `Array.prototype.reduce`
- `Array.prototype.reduceRight`
- `Array.prototype.find`
- `Array.prototype.findIndex`
- `Array.prototype.some`
- `Array.prototype.every`

Кроме того, мы расширили быстрый путь для всех этих функций. Вначале мы прекращали выполнение при обнаружении массивов с числами с плавающей точкой или [при наличии «дыр» в массивах](/blog/elements-kinds), например `[3, 4.5, , 6]`. Теперь мы обрабатываем дырявые массивы с числами с плавающей точкой повсеместно, кроме функций `find` и `findIndex`, где требование спецификации превращать «дырки» в `undefined` мешает нашим усилиям (_пока что…!_).

На следующем изображении показана дельта улучшения по сравнению с V8 v6.4 в наших встроенных функциях, разделенных на массивы целых чисел, массивы с плавающей точкой и массивы с плавающей точкой с пропусками. Время указано в миллисекундах.

![Улучшения производительности с момента V8 v6.4](/_img/v8-release-65/performance-improvements.svg)

## API V8

Пожалуйста, используйте `git log branch-heads/6.4..branch-heads/6.5 include/v8.h`, чтобы получить список изменений API.

Разработчики с [актуальной копией исходного кода V8](/docs/source-code#using-git) могут использовать `git checkout -b 6.5 -t branch-heads/6.5`, чтобы поэкспериментировать с новыми функциями в V8 v6.5. Альтернативно, вы можете [подписаться на бета-канал Chrome](https://www.google.com/chrome/browser/beta.html) и вскоре сами попробовать новые функции.
