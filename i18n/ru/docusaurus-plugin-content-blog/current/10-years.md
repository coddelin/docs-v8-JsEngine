---
title: "Празднование 10-летия V8"
author: "Mathias Bynens ([@mathias](https://twitter.com/mathias)), историк V8"
avatars:
  - "mathias-bynens"
date: 2018-09-11 19:00:00
tags:
  - benchmarks
description: "Обзор основных этапов проекта V8 за последние 10 лет, а также за годы до этого, когда проект был ещё секретным."
tweet: "1039559389324238850"
---
В этом месяце отмечается десятилетие не только выпуска Google Chrome, но и проекта V8. В этом посте представлен обзор основных этапов проекта V8 за последние 10 лет, а также за годы до этого, когда проект был ещё секретным.

<!--truncate-->
<figure>
  <div class="video video-16:9">
    <iframe src="https://www.youtube.com/embed/G0vnrPTuxZA" width="640" height="360" loading="lazy"></iframe>
  </div>
  <figcaption>Визуализация базы кода V8 за время её существования, созданная с помощью <a href="http://gource.io/"><code>gource</code></a>.</figcaption>
</figure>

## До выпуска V8: ранние годы

Google наняла [Ларса Бака](https://en.wikipedia.org/wiki/Lars_Bak_%28computer_programmer%29) осенью **2006 года** для разработки нового JavaScript-движка для веб-браузера Chrome, который на тот момент оставался секретным внутренним проектом Google. Ларс недавно вернулся в Орхус, Дания, из Силиконовой долины. Так как в Орхусе не было офиса Google, а Ларс хотел остаться в Дании, он и несколько инженеров, работавших над проектом, начали работать в пристройке на его ферме. Новый JavaScript-движок получил название “V8”, что является игривой отсылкой к мощному двигателю, который можно найти в классическом маслкаре. Позже, когда команда V8 выросла, разработчики переехали из скромных помещений на ферме в современное офисное здание в Орхусе, но сохранили свою целеустремлённость и фокус на создании самого быстрого JavaScript-движка в мире.

## Запуск и развитие V8

V8 стал открытым исходным проектом в тот же день, когда [был запущен Chrome](https://blog.chromium.org/2008/09/welcome-to-chromium_02.html): 2 сентября **2008 года**. [Первый коммит](https://chromium.googlesource.com/v8/v8/+/43d26ecc3563a46f62a0224030667c8f8f3f6ceb) был сделан 30 июня 2008 года. До этой даты разработка V8 велась в закрытом репозитории CVS. Изначально V8 поддерживал только инструкции ia32 и ARM и использовал [SCons](https://scons.org/) в качестве системы сборки.

В **2009 году** был представлен абсолютно новый движок для регулярных выражений под названием [Irregexp](https://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html), что привело к улучшению производительности для реальных регулярных выражений. С добавлением порта для x64 количество поддерживаемых наборов инструкций увеличилось с двух до трёх. 2009 год также ознаменовался [первым выпуском проекта Node.js](https://github.com/nodejs/node-v0.x-archive/releases/tag/v0.0.1), который использует движок V8. Возможность использовать V8 в проектах вне браузера была [явно упомянута](https://www.google.com/googlebooks/chrome/big_16.html) в оригинальном комиксе Chrome. С Node.js это стало реальностью! Node.js выросла в одну из самых популярных экосистем JavaScript.

В **2010 году** производительность движка значительно повысилась благодаря введению нового оптимизирующего JIT-компилятора. [Crankshaft](https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html) генерировал машинный код, который был в два раза быстрее и на 30% меньше, чем предыдущий (безымянный) компилятор V8. В том же году V8 добавил четвёртый набор инструкций: 32-битный MIPS.

В **2011 году** значительно улучшилась система сборки мусора. [Новый инкрементальный сборщик мусора](https://blog.chromium.org/2011/11/game-changer-for-interactive.html) существенно сократил время паузы, поддерживая отличную производительность и низкое использование памяти. V8 представил концепцию Изолятов, которая позволяет внедрять несколько экземпляров движка V8 в одном процессе, проложив путь для легковесных веб-воркеров в Chrome. Произошла первая миграция системы сборки, когда мы перешли с SCons на [GYP](https://gyp.gsrc.io/). Были реализованы поддержка строгого режима ES5 и другие улучшения. Между тем разработка переехала из Орхуса в Мюнхен (Германия) под новым руководством с активным взаимодействием с оригинальной командой Орхуса.

**2012** год стал годом установления ключевых показателей для проекта V8. Команда проводила ускоренные спринты для оптимизации производительности V8, измеряемой с помощью наборов тестов [SunSpider](https://webkit.org/perf/sunspider/sunspider.html) и [Kraken](https://krakenbenchmark.mozilla.org/). Позже мы разработали новый набор тестов под названием [Octane](https://chromium.github.io/octane/) (с [V8 Bench](http://www.netchain.com/Tools/v8/) в его основе), который сделал соревнование по достижению максимальной производительности одной из главных задач и стимулировал значительные улучшения в технологиях выполнения и JIT во всех основных JS-движках. Одним из результатов этих усилий стал переход от случайного выборочного профилирования к детерминированной, основанной на счёте технике для обнаружения “горячих” функций в профайлере времени выполнения V8, что значительно снизило вероятность случайного замедления загрузки страниц (или запуска тестов).

**2013** стал годом появления низкоуровневого подмножества JavaScript, названного [asm.js](http://asmjs.org/). Поскольку asm.js ограничен статически типизированной арифметикой, вызовами функций и доступом к куче только с примитивными типами, проверенный код asm.js мог выполняться с предсказуемой производительностью. Мы выпустили новую версию Octane — [Octane 2.0](https://blog.chromium.org/2013/11/announcing-octane-20.html) с обновлениями существующих тестов, а также новыми тестами, нацеленными на такие сценарии использования, как asm.js. Octane стимулировал разработку новых оптимизаций компилятора, таких как [свёртка распределений](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/42478.pdf) и [оптимизации распределений на основе мест переходов типов и преждевременных выделений](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43823.pdf), которые сильно улучшили пиковую производительность. В рамках инициативы, которую мы внутри команды назвали “Handlepocalypse”, API для работы с хендлами в V8 был полностью переписан, чтобы сделать его более простым и безопасным в использовании. Также в 2013 году реализация `TypedArray` в JavaScript в Chrome была [перемещена из Blink в V8](https://codereview.chromium.org/13064003).

В **2014** году V8 перенес часть работы по JIT-компиляции с основного потока на [параллельную компиляцию](https://blog.chromium.org/2014/02/compiling-in-background-for-smoother.html), что уменьшило задержки и значительно повысило производительность. Позже в этом году мы [запустили](https://github.com/v8/v8/commit/a1383e2250dc5b56b777f2057f1600537f02023e) начальную версию нового оптимизирующего компилятора под названием TurboFan. Тем временем наши партнёры помогли портировать V8 для трёх новых архитектур набора инструкций: PPC, MIPS64 и ARM64. Вслед за Chromium, V8 перешел на ещё одну систему сборки — [GN](https://gn.googlesource.com/gn/#gn). Тестовая инфраструктура V8 была значительно улучшена: _Tryserver_ теперь позволял тестировать каждый патч на различных сборочных ботах перед его интеграцией. Для контроля версий V8 перешёл с SVN на Git.

**2015** был насыщенным годом для V8 по многим направлениям. Мы реализовали [кэширование кода и потоковую обработку скриптов](https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html), что значительно ускорило загрузку веб-страниц. Работа над использованием мементов распределения в нашей системе времени выполнения была [опубликована на ISMM 2015](https://ai.google/research/pubs/pub43823). Позже в этом году мы [начали](https://github.com/v8/v8/commit/7877c4e0c77b5c2b97678406eab7e9ad6eba4a4d) работу над новым интерпретатором под названием Ignition. Мы экспериментировали с идеей подмножества JavaScript, названного [strong mode](https://docs.google.com/document/d/1Qk0qC4s_XNCLemj42FqfsRLp49nDQMZ1y7fwf5YjaI4/view), чтобы достичь более строгих гарантий и предсказуемой производительности. Strong mode был реализован за флагом, но позже мы обнаружили, что его преимущества не оправдывают затраты. Добавление [очереди коммитов](https://dev.chromium.org/developers/testing/commit-queue) значительно улучшило производительность и стабильность разработки. Сборщик мусора в V8 также начал сотрудничать с внедренным программным обеспечением, таким как Blink, для планирования работы сборщика мусора в периоды простоя. [Сборка мусора в периоды простоя](/blog/free-garbage-collection) существенно снизила визуальные задержки, связанные с сборкой мусора, и объемы используемой памяти. В декабре [первая сборка WebAssembly](https://github.com/titzer/v8-native-prototype) была интегрирована в V8.

В **2016** году мы завершили работу над последними элементами ES2015 (ранее известного как "ES6") — набора функций (включая промисы, синтаксис классов, лексическое замыкание, деструктуризацию и другие), а также некоторыми функциями ES2016. Мы начали внедрение новой конвейерной системы Ignition и TurboFan, используя её для [компиляции и оптимизации функций ES2015 и ES2016](/blog/v8-release-56), и сделали Ignition стандартным для [бюджетных устройств на Android](/blog/ignition-interpreter). Успешная работа по сбору мусора в режиме ожидания была представлена на [PLDI 2016](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45361.pdf). Мы запустили [проект Orinoco](/blog/orinoco) — новый, в основном параллельный и конкурентный сборщик мусора для V8, чтобы сократить время сборки мусора основным потоком. В рамках крупной переориентации мы сместили акцент с синтетических микро-бенчмарков на серьёзное измерение и оптимизацию [производительности в реальных условиях](/blog/real-world-performance). Для отладки инспектор V8 был [перемещён](/blog/v8-release-55) из Chromium в V8, что позволило любому пользователю V8 (а не только Chromium) использовать Chrome DevTools для отладки JavaScript, работающего в V8. Прототип WebAssembly перешёл от прототипа к экспериментальной поддержке, в координации с другими поставщиками браузеров [экспериментальная поддержка WebAssembly](/blog/webassembly-experimental). V8 получил [премию ACM SIGPLAN Programming Languages Software Award](http://www.sigplan.org/Awards/Software/). И был добавлен ещё один порт: S390.

В **2017** году мы наконец завершили многолетнюю капитальную переработку движка, включив новую конвейерную систему [Ignition и TurboFan](/blog/launching-ignition-and-turbofan) по умолчанию. Это позволило впоследствии удалить Crankshaft ([130,380 удалённых строк кода](https://chromium-review.googlesource.com/c/v8/v8/+/547717)) и [Full-codegen](https://chromium-review.googlesource.com/c/v8/v8/+/584773) из базы кода. Мы запустили Orinoco v1.0, включая [конкурентную маркировку](/blog/concurrent-marking), конкурентную зачистку, параллельное зачистку и параллельную компактацию. Мы официально признали Node.js как полноценного пользователя V8 наряду с Chromium. С тех пор любой патч для V8 не может быть принят, если он нарушает тестовый набор Node.js. Наша инфраструктура получила поддержку fuzz-тестирования корректности, обеспечивая, что любой кусок кода будет давать последовательные результаты независимо от конфигурации, в которой он выполняется.

В рамках масштабного отраслевого запуска V8 [включил WebAssembly по умолчанию](/blog/v8-release-57). Мы реализовали поддержку [модулей JavaScript](/features/modules), а также полный набор функций ES2017 и ES2018 (включая асинхронные функции, общую память, асинхронную итерацию, свойства rest/spread и функции RegExp). Мы внедрили [родную поддержку покрытия кода JavaScript](/blog/javascript-code-coverage) и запустили [Web Tooling Benchmark](/blog/web-tooling-benchmark), чтобы помочь нам измерить, как оптимизации V8 влияют на производительность инструментов разработки в реальном мире и на JavaScript-код, который они генерируют. [Трассировка обёртки](/blog/tracing-js-dom) из объектов JavaScript в объекты DOM на C++ и обратно позволила нам устранить давние утечки памяти в Chrome и эффективно обрабатывать транзитивное замыкание объектов между кучами JavaScript и Blink. Впоследствии мы использовали эту инфраструктуру для увеличения возможностей инструмента снимков состояния кучи.

В **2018** году произошло отраслевое событие, перевернувшее наши представления о безопасности информации на уровне процессоров: публичное раскрытие [уязвимостей Spectre/Meltdown](https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html). Инженеры V8 провели масштабное исследование для понимания угрозы для управляемых языков и разработки мер её устранения. V8 внедрил [меры защиты](/docs/untrusted-code-mitigations) от Spectre и подобных атак через побочные каналы для пользователей, запускающих недоверенный код.

Недавно мы выпустили базовый компилятор для WebAssembly, названный [Liftoff](/blog/liftoff), который значительно уменьшает время запуска приложений на WebAssembly, сохраняя при этом предсказуемую производительность. Мы внедрили [`BigInt`](/blog/bigint), новый примитив JavaScript, который позволяет работать с [целыми числами произвольной точности](/features/bigint). Мы реализовали [встроенные функции](/blog/embedded-builtins) и сделали их возможным [медленно десериализовать](/blog/lazy-deserialization), существенно уменьшая объём V8 для нескольких изолятов. Мы дали возможность [компилировать байткод скриптов в фоне](/blog/background-compilation). Мы начали [проект объединённой кучи V8-Blink](https://docs.google.com/presentation/d/12ZkJ0BZ35fKXtpM342PmKM5ZSxPt03_wsRgbsJYl3Pc), чтобы выполнять синхронную сборку мусора для компонентов V8 и Blink. И год ещё не закончился…

## Перепады производительности

Результаты теста V8 Bench для Chrome в течение нескольких лет показывают влияние изменений V8 на производительность. (Мы используем тест V8 Bench, поскольку это один из немногих тестов, который всё ещё может запускаться в оригинальной бета-версии Chrome.)

![Результаты теста Chrome [V8 Bench](http://www.netchain.com/Tools/v8/) с 2008 по 2018 год](/_img/10-years/v8-bench.svg)

Наш результат в этом тесте увеличился в **4 раза** за последние десять лет!

Однако вы могли заметить два понижения производительности за эти годы. Они оба интересны, так как соответствуют значительным событиям в истории V8. Снижение производительности в 2015 году произошло, когда V8 внедрил базовые версии функций ES2015. Эти функции сильно затрагивали кодовую базу V8, и мы сосредоточились на корректности, а не на производительности для их начального выпуска. Мы приняли эти незначительные регрессии скорости, чтобы как можно быстрее предоставить функции разработчикам. В начале 2018 года была раскрыта уязвимость Spectre, и V8 внедрил меры защиты, чтобы защитить пользователей от потенциальных эксплойтов, что привело к другой регрессии производительности. К счастью, теперь, когда Chrome внедряет [изоляцию сайтов](https://developers.google.com/web/updates/2018/07/site-isolation), мы можем снова отключить меры защиты, возвращая производительность на прежний уровень.

Еще один вывод из этого графика заключается в том, что он начинает выравниваться примерно в 2013 году. Означает ли это, что V8 сдался и перестал инвестировать в производительность? Совсем наоборот! Выравнивание графиков отражает переход команды V8 от синтетических микро-тестов (таких как V8 Bench и Octane) к оптимизации для [реальной производительности](/blog/real-world-performance). V8 Bench — это старый тест, который не использует никаких современных функций JavaScript и не приближается к реальному производственному коду. Сравните это с более новой тестовой системой Speedometer:

![Результаты Chrome в Speedometer 1 с 2013 по 2018 годы](/_img/10-years/speedometer-1.svg)

Хотя V8 Bench показывает минимальные улучшения с 2013 по 2018 год, наш результат Speedometer 1 за это же время вырос (еще на) **4×**. (Мы использовали Speedometer 1, так как Speedometer 2 использует современные функции JavaScript, которые еще не поддерживались в 2013 году.)

В настоящее время у нас есть [еще лучшее](/blog/speedometer-2) [тестирование](/blog/web-tooling-benchmark), которое точнее отражает современные приложения JavaScript, а также мы [активно измеряем и оптимизируем существующие веб-приложения](https://www.youtube.com/watch?v=xCx4uC7mn6Y).

## Резюме

Хотя V8 изначально был создан для Google Chrome, он всегда был автономным проектом с отдельной базой кода и API встроения, который позволяет любому приложению использовать его службы выполнения JavaScript. За последние 10 лет открытый характер проекта помог ему стать ключевой технологией не только для веб-платформы, но и в других контекстах, таких как Node.js. В процессе проект развивался и оставался актуальным, несмотря на многочисленные изменения и драматический рост.

Изначально V8 поддерживал только два набора инструкций. За последние 10 лет список поддерживаемых платформ достиг восьми: ia32, x64, ARM, ARM64, 32- и 64-битный MIPS, 64-битный PPC и S390. Система сборки V8 мигрировала от SCons к GYP и затем к GN. Проект переместился из Дании в Германию и теперь имеет инженеров по всему миру, включая Лондон, Маунтин-Вью и Сан-Франциско, а также участников вне Google из множества других мест. Мы преобразовали весь наш процесс компиляции JavaScript от безымянных компонентов к Full-codegen (базовый компилятор) и Crankshaft (оптимизирующий компилятор с обратной связью) к Ignition (интерпретатор) и TurboFan (лучший оптимизирующий компилятор с обратной связью). V8 перешел от того, чтобы быть «просто» движком JavaScript, к поддержке также WebAssembly. Сам язык JavaScript эволюционировал от ECMAScript 3 к ES2018; последний V8 даже реализует функции, появившиеся после ES2018.

История развития интернета — длинная и продолжающаяся. Отмечая 10-летие Chrome и V8, стоит помнить, что, хотя это и значительная веха, рассказ о веб-платформе длится уже более 25 лет. У нас нет сомнений, что история интернета продолжится как минимум еще столько же. Мы стремимся к тому, чтобы V8, JavaScript и WebAssembly продолжали оставаться интересными персонажами этого повествования. Мы с нетерпением ждем, что принесет нам следующий десяток лет. Следите за обновлениями!
