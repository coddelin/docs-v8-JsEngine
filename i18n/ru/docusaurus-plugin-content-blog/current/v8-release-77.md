---
title: 'V8 версия v7.7'
author: 'Mathias Bynens ([@mathias](https://twitter.com/mathias)), ленивый составитель заметок о выпуске'
avatars:
  - 'mathias-bynens'
date: 2019-08-13 16:45:00
tags:
  - выпуск
description: 'V8 v7.7 включает ленивое выделение обратной связи, более быструю фоновую компиляцию WebAssembly, улучшение трассировки стека и новую функциональность Intl.NumberFormat.'
tweet: '1161287541611323397'
---
Каждые шесть недель мы создаем новую ветку V8 в рамках нашего [процесса выпуска](/docs/release-process). Каждая версия создается из основной ветки Git V8 непосредственно перед этапом бета-версии Chrome. Сегодня мы рады объявить о нашей новой ветке, [версия V8 7.7](https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/7.7), которая находится в стадии бета-тестирования до выпуска вместе с Chrome 77 Stable через несколько недель. V8 v7.7 насыщен всякими полезностями для разработчиков. Этот пост предоставляет предварительный обзор некоторых из наиболее ярких моментов в ожидании выпуска.

<!--truncate-->
## Производительность (размер и скорость)

### Ленивое выделение обратной связи

Для оптимизации JavaScript V8 собирает данные об типах операндов, передаваемых различным операциям (например, `+` или `o.foo`). Эти данные используются для оптимизации операций, адаптируя их к конкретным типам. Эта информация хранится в «векторах обратной связи», и хотя она очень важна для достижения более высокой скорости выполнения, мы также платим за память, необходимую для выделения этих векторов.

Чтобы сократить использование памяти V8, мы теперь выделяем векторы обратной связи лениво, только после того как функция выполнит определенное количество байт-кода. Это позволяет избежать выделения векторов обратной связи для недолговечных функций, которые не выигрывают от собранной обратной связи. Наши лабораторные эксперименты показывают, что ленивое выделение векторов обратной связи экономит около 2–8% размера кучи V8.

![](/_img/v8-release-77/lazy-feedback-allocation.svg)

Наши эксперименты в реальных условиях показывают, что это сокращает размер кучи V8 на 1–2% на настольных компьютерах и на 5–6% на мобильных платформах для пользователей Chrome. На настольных компьютерах нет регрессий производительности, а на мобильных платформах мы даже наблюдали улучшение производительности на бюджетных телефонах с ограниченной памятью. Пожалуйста, следите за более подробным постом в блоге о нашей недавней работе по сохранению памяти.

### Масштабируемая фоновая компиляция WebAssembly

На протяжении последних этапов мы работали над масштабируемостью фоновой компиляции WebAssembly. Чем больше ядер у вашего компьютера, тем больше вы выигрываете от этой работы. Графики ниже были созданы на 24-ядерной машине Xeon, компилируя [демо Epic ZenGarden](https://s3.amazonaws.com/mozilla-games/ZenGarden/EpicZenGarden.html). В зависимости от количества используемых потоков компиляция занимает менее половины времени по сравнению с V8 v7.4.

![](/_img/v8-release-77/liftoff-compilation-speedup.svg)

![](/_img/v8-release-77/turbofan-compilation-speedup.svg)

### Улучшение трассировки стека

Практически все ошибки, выбрасываемые V8, захватывают трассировку стека при их создании. Эта трассировка стека может быть доступна из JavaScript через нестандартное свойство `error.stack`. При первом доступе к трассировке стека через `error.stack` V8 сериализует структурированную трассировку стека в строку. Эта сериализованная трассировка стека сохраняется для ускорения последующих обращений к `error.stack`.

За последние несколько версий мы работали над некоторыми [внутренними переработками логики трассировки стека](https://docs.google.com/document/d/1WIpwLgkIyeHqZBc9D3zDtWr7PL-m_cH6mfjvmoC6kSs/edit) ([отслеживающий баг](https://bugs.chromium.org/p/v8/issues/detail?id=8742)), упрощая код и улучшая производительность сериализации трассировки стека на 30%.

## Особенности языка JavaScript

[API `Intl.NumberFormat`](/features/intl-numberformat) для локализованного форматирования чисел обретает новую функциональность в этом выпуске! Теперь поддерживаются компактное обозначение, научная нотация, инженерная нотация, отображение знаков и единицы измерения.

```js
const formatter = new Intl.NumberFormat('en', {
  style: 'unit',
  unit: 'meter-per-second',
});
formatter.format(299792458);
// → '299,792,458 м/с'
```

Обратитесь к [нашему объяснению функций](/features/intl-numberformat) для получения более подробной информации.

## API V8

Пожалуйста, используйте `git log branch-heads/7.6..branch-heads/7.7 include/v8.h`, чтобы получить список изменений API.

Разработчики с [активной копией V8](/docs/source-code#using-git) могут использовать `git checkout -b 7.7 -t branch-heads/7.7`, чтобы экспериментировать с новыми функциями в V8 v7.7. Кроме того, вы можете [подписаться на бета-канал Chrome](https://www.google.com/chrome/browser/beta.html) и вскоре попробовать новые функции сами.
