---
title: "Оптимизация прокси ES2015 в V8"
author: "Мая Армянова ([@Zmayski](https://twitter.com/Zmayski)), оптимизатор прокси"
avatars:
  - "maya-armyanova"
date: 2017-10-05 13:33:37
tags:
  - ECMAScript
  - тесты производительности
  - внутреннее устройство
description: "Эта статья объясняет, как V8 улучшил производительность JavaScript прокси."
tweet: "915846050447003648"
---
Прокси являются неотъемлемой частью JavaScript с момента появления ES2015. Они позволяют перехватывать основные операции с объектами и настраивать их поведение. Прокси являются ключевой частью таких проектов, как [jsdom](https://github.com/tmpvar/jsdom) и библиотека [Comlink RPC](https://github.com/GoogleChrome/comlink). Недавно мы приложили немало усилий для улучшения производительности прокси в V8. Эта статья проливает свет на общие шаблоны улучшения производительности в V8, а также на прокси в частности.

<!--truncate-->
Прокси — это «объекты, которые используются для определения пользовательского поведения для основных операций (например, поиска свойства, присваивания значения, перечисления, вызова функции и т.д.)» (определение по [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)). Дополнительную информацию можно найти в [полной спецификации](https://tc39.es/ecma262/#sec-proxy-objects). Например, следующий код добавляет логирование для каждого доступа к свойству объекта:

```js
const target = {};
const callTracer = new Proxy(target, {
  get: (target, name, receiver) => {
    console.log(`get был вызван для: ${name}`);
    return target[name];
  }
});

callTracer.property = 'value';
console.log(callTracer.property);
// get был вызван для: property
// value
```

## Создание прокси

Первая функция, на которой мы сосредоточимся, — это **создание** прокси. Наша оригинальная реализация на C++ следовала шаг за шагом спецификации ECMAScript, что приводило к как минимум 4 переходам между C++ и JS рантаймами, как показано на следующем рисунке. Мы хотели перенести эту реализацию на платформо-независимый [CodeStubAssembler](/docs/csa-builtins) (CSA), который выполняется в JS рантайме вместо C++ рантайма. Такое перенесение минимизировало количество переходов между языковыми рантаймами. `CEntryStub` и `JSEntryStub` представляют рантаймы на рисунке ниже. Пунктирные линии обозначают границы между JS и C++ рантаймами. К счастью, многие [вспомогательные предикаты](https://github.com/v8/v8/blob/4e5db9a6c859df7af95a92e7cf4e530faa49a765/src/code-stub-assembler.h) уже были реализованы в ассемблере, что сделало [начальную версию](https://github.com/v8/v8/commit/f2af839b1938b55b4d32a2a1eb6704c49c8d877d#diff-ed49371933a938a7c9896878fd4e4919R97) краткой и понятной.

На рисунке ниже показано выполнение вызова прокси с любой ловушкой прокси (в данном примере `apply`, который вызывается, когда прокси используется как функция), созданной следующим примером кода:

```js
function foo(…) { … }
const g = new Proxy({ … }, {
  apply: foo,
});
g(1, 2);
```

![](/_img/optimizing-proxies/0.png)

После переноса выполнения ловушки в CSA вся обработка происходит в JS рантайме, снижая количество переходов между языками с 4 до 0.

Это изменение привело к следующим улучшениям производительности::

![](/_img/optimizing-proxies/1.png)

Наш показатель производительности JS показывает улучшение от **49% до 74%**. Этот показатель примерно измеряет, сколько раз данный микробенчмарк может быть выполнен за 1000 мс. Для некоторых тестов код выполняется несколько раз, чтобы получить достаточно точное измерение при данном разрешении таймера. Код для всех последующих тестов производительности можно найти [в директории js-perf-test](https://github.com/v8/v8/blob/5a5783e3bff9e5c1c773833fa502f14d9ddec7da/test/js-perf-test/Proxies/proxies.js).

## Ловушки вызова и создания

В следующем разделе показаны результаты оптимизации ловушек вызова и создания (т.н. [`"apply"`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply)" и [`"construct"`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/construct)).

![](/_img/optimizing-proxies/2.png)

Улучшения производительности при _вызове_ прокси значительны — до **500%** быстрее! Тем не менее, прирост производительности при создании прокси довольно скромен, особенно в случаях, когда нет фактической определенной ловушки — всего около **25%** прироста. Мы исследовали это, запустив следующую команду с использованием [оболочки `d8`](/docs/build):

```bash
$ out/x64.release/d8 --runtime-call-stats test.js
> run: 120.104000

                      Функция Runtime/C++ Builtin        Время             Количество
========================================================================================
                                         NewObject     59.16ms  48.47%    100000  24.94%
                                      JS_Execution     23.83ms  19.53%         1   0.00%
                              RecompileSynchronous     11.68ms   9.57%        20   0.00%
                        AccessorNameGetterCallback     10.86ms   8.90%    100000  24.94%
      AccessorNameGetterCallback_FunctionPrototype      5.79ms   4.74%    100000  24.94%
                                  Map_SetPrototype      4.46ms   3.65%    100203  25.00%
… ФРАГМЕНТ …
```

Где исходный код `test.js`:

```js
function MyClass() {}
MyClass.prototype = {};
const P = new Proxy(MyClass, {});
function run() {
  return new P();
}
const N = 1e5;
console.time('run');
for (let i = 0; i < N; ++i) {
  run();
}
console.timeEnd('run');
```

Оказалось, что большая часть времени тратится на `NewObject` и функции, вызываемые им, поэтому мы начали планировать, как ускорить этот процесс в будущих релизах.

## Ловушка get

Следующий раздел описывает, как мы оптимизировали другие наиболее распространенные операции — получение и установку свойств через прокси. Оказалось, что [`get`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get) ловушка более сложна, чем предыдущие случаи, из-за специфического поведения встроенного кэша V8. Для подробного объяснения встроенных кэшей можно посмотреть [эту лекцию](https://www.youtube.com/watch?v=u7zRSm8jzvA).

В итоге нам удалось адаптировать это для CSA с следующими результатами:

![](/_img/optimizing-proxies/3.png)

После внесения изменений мы заметили, что размер `.apk` для Chrome на Android увеличился на **~160КБ**, что больше ожидаемого для вспомогательной функции длиной примерно 20 строк, но, к счастью, мы отслеживаем такую статистику. Оказалось, что эта функция вызывается дважды из другой функции, которая, в свою очередь, вызывается 3 раза, а затем — 4 раза. Причиной проблемы оказалось агрессивное встраивание. В конечном итоге мы решили проблему, превратив встроенную функцию в отдельный кодовый фрагмент, тем самым сохранив драгоценные килобайты — итоговая версия увеличила размер `.apk` только на **~19КБ**.

## Ловушка has

Следующий раздел демонстрирует результаты оптимизации [`has`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/has) ловушки. Хотя сначала мы думали, что это будет легче (и можно будет переиспользовать большую часть кода ловушки `get`), оказалось, что у неё есть свои особенности. Особенно сложной для отслеживания оказалась проблема с проходом по цепочке прототипов при использовании оператора `in`. Достигнутые улучшения варьируются в пределах от **71% до 428%**. Опять же, выгода более значительна в случаях, когда ловушка есть.

![](/_img/optimizing-proxies/4.png)

## Ловушка set

Следующий раздел рассказывает о переносе [`set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set) ловушки. На этот раз мы должны были различать [именованные](/blog/fast-properties) и индексируемые свойства ([элементы](/blog/elements-kinds)). Эти два основных типа не являются частью языка JS, но играют ключевую роль в эффективном хранении свойств в V8. Первоначальная реализация всё ещё возвращалась к времени выполнения для элементов, что вызывает пересечение языковых границ. Тем не менее, мы достигли улучшений от **27% до 438%** в случаях, когда ловушка выставлена, за счёт уменьшения производительности до **23%**, когда её нет. Это снижение производительности связано с дополнительной проверкой для различения индексируемых и именованных свойств. Пока что для индексируемых свойств улучшений ещё нет. Вот полные результаты:

![](/_img/optimizing-proxies/5.png)

## Использование в реальном мире

### Результаты из [jsdom-proxy-benchmark](https://github.com/domenic/jsdom-proxy-benchmark)

Проект jsdom-proxy-benchmark компилирует [спецификацию ECMAScript](https://github.com/tc39/ecma262) с использованием инструмента [Ecmarkup](https://github.com/bterlson/ecmarkup). Начиная с версии [v11.2.0](https://github.com/tmpvar/jsdom/blob/master/Changelog.md#1120), проект jsdom (который лежит в основе Ecmarkup) использует прокси для реализации общих структур данных `NodeList` и `HTMLCollection`. Мы использовали этот тест для получения обзора более реалистичного использования, чем синтетические микротесты, и получили следующие результаты, в среднем 100 запусков:

- Node v8.4.0 (без оптимизаций Proxy): **14277 ± 159 мс**
- [Node v9.0.0-v8-canary-20170924](https://nodejs.org/download/v8-canary/v9.0.0-v8-canary20170924898da64843/node-v9.0.0-v8-canary20170924898da64843-linux-x64.tar.gz) (с только половиной перенесённых ловушек): **11789 ± 308 мс**
- Прирост скорости около 2.4 секунд, что составляет **~17% лучше**

![](/_img/optimizing-proxies/6.png)

- [Конвертация `NamedNodeMap` для использования `Proxy`](https://github.com/domenic/jsdom-proxy-benchmark/issues/1#issuecomment-329047990) увеличила время обработки на
    - **1.9 с** на V8 6.0 (Node v8.4.0)
    - **0.5 с** на V8 6.3 (Node v9.0.0-v8-canary-20170910)

![](/_img/optimizing-proxies/7.png)

:::примечание
**Примечание:** Эти результаты были предоставлены [Timothy Gu](https://github.com/TimothyGu). Спасибо!
:::

### Результаты от [Chai.js](https://chaijs.com/)

Chai.js — это популярная библиотека утверждений, активно использующая прокси. Мы создали своего рода реальный тест производительности, запустив её тесты с разными версиями V8, улучшение составило примерно **1 секунда из более чем 4 секунд**, среднее значение из 100 запусков:

- Node v8.4.0 (без оптимизаций Proxy): **4.2863 ± 0.14 с**
- [Node v9.0.0-v8-canary-20170924](https://nodejs.org/download/v8-canary/v9.0.0-v8-canary20170924898da64843/node-v9.0.0-v8-canary20170924898da64843-linux-x64.tar.gz) (с только половиной портированных ловушек): **3.1809 ± 0.17 с**

![](/_img/optimizing-proxies/8.png)

## Подход к оптимизации

Мы часто решаем задачи производительности, используя универсальную схему оптимизации. Основной подход, которого мы придерживались в рамках данной работы, включал следующие шаги:

- Реализация тестов производительности для конкретного подфункционала
- Добавление дополнительных тестов на соответствие спецификациям (или их написание с нуля)
- Исследование исходной реализации на C++
- Портирование подфункционала в независимый от платформы CodeStubAssembler
- Дальнейшая оптимизация кода вручную с использованием [TurboFan](/docs/turbofan)
- Измерение прироста производительности.

Этот подход можно применять для любой общей задачи оптимизации, которая у вас есть.
