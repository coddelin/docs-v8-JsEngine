---
title: 'Анонс Web Tooling Benchmark'
author: 'Бенедикт Мойрер ([@bmeurer](https://twitter.com/bmeurer)), жонглёр производительности JavaScript'
avatars:
  - 'benedikt-meurer'
date: 2017-11-06 13:33:37
tags:
  - бенчмарки
  - Node.js
description: 'Совершенно новый Web Tooling Benchmark помогает выявлять и устранять узкие места производительности V8 в Babel, TypeScript и других реальных проектах.'
tweet: '927572065598824448'
---
Производительность JavaScript всегда была важна для команды V8, и в этом посте мы хотели бы обсудить новый JavaScript [Web Tooling Benchmark](https://v8.github.io/web-tooling-benchmark), который мы недавно начали использовать для выявления и устранения некоторых узких мест производительности в V8. Вы, возможно, уже знаете о [сильной приверженности V8 для Node.js](/blog/v8-nodejs), и этот бенчмарк расширяет эту приверженность, проводя тесты производительности на основе общих инструментов разработчиков, построенных на Node.js. Инструменты, представленные в Web Tooling Benchmark, — это те же самые инструменты, которые сегодня используются разработчиками и дизайнерами для создания современных веб-сайтов и облачных приложений. В продолжение наших постоянных усилий сосредоточиться на [реальной производительности](/blog/real-world-performance/), а не на искусственных тестах, мы создали этот бенчмарк, используя реальный код, который разработчики используют каждый день.

<!--truncate-->
Пакет тестов Web Tooling Benchmark был с самого начала разработан для охвата важных [сценариев использования инструментов разработчиков](https://github.com/nodejs/benchmarking/blob/master/docs/use_cases.md#web-developer-tooling) для Node.js. Поскольку команда V8 сосредоточена на производительности базового JavaScript, мы создали этот бенчмарк таким образом, чтобы он фокусировался на нагрузках JavaScript и исключал измерения специфического для Node.js ввода-вывода или внешних взаимодействий. Это позволяет запускать бенчмарк в Node.js, во всех браузерах и во всех основных оболочках JavaScript-движков, включая `ch` (ChakraCore), `d8` (V8), `jsc` (JavaScriptCore) и `jsshell` (SpiderMonkey). Хотя бенчмарк не ограничен только Node.js, мы рады, что [рабочая группа по бенчмаркам Node.js](https://github.com/nodejs/benchmarking) рассматривает возможность использования инструмента как стандарта для производительности Node.js ([nodejs/benchmarking#138](https://github.com/nodejs/benchmarking/issues/138)).

Отдельные тесты в инструментальном бенчмарке охватывают различные инструменты, которые разработчики обычно используют для создания JavaScript-приложений, например:

- Транспайлер [Babel](https://github.com/babel/babel), использующий пресет `es2015`.
- Парсер, используемый Babel — [Babylon](https://github.com/babel/babylon), работающий с несколькими популярными входными данными (включая пакеты [lodash](https://lodash.com/) и [Preact](https://github.com/developit/preact)).
- Парсер [acorn](https://github.com/ternjs/acorn), используемый [webpack](http://webpack.js.org/).
- Компилятор [TypeScript](http://www.typescriptlang.org/), работающий с примером проекта [typescript-angular](https://github.com/tastejs/todomvc/tree/master/examples/typescript-angular) из проекта [TodoMVC](https://github.com/tastejs/todomvc).

См. [подробный анализ](https://github.com/v8/web-tooling-benchmark/blob/master/docs/in-depth.md) для деталей по всем включённым тестам.

Опираясь на прошлый опыт с другими бенчмарками, такими как [Speedometer](http://browserbench.org/Speedometer), где тесты быстро устаревают с появлением новых версий фреймворков, мы позаботились о том, чтобы обновление каждого из инструментов в бенчмарках до более современных версий было прямолинейным процессом. Основанный на инфраструктуре npm, наш бенчмарк можно легко обновлять, чтобы гарантировать, что он всегда тестирует самые современные инструменты JavaScript-разработки. Обновление тестового случая — это просто вопрос увеличения версии в манифесте `package.json`.

Мы создали [отслеживаемую ошибку](http://crbug.com/v8/6936) и [электронную таблицу](https://docs.google.com/spreadsheets/d/14XseWDyiJyxY8_wXkQpc7QCKRgMrUbD65sMaNvAdwXw) для записи всей информации, которую мы собрали о производительности V8 на новом бенчмарке до этого момента. Наши исследования уже дали интересные результаты. Например, мы обнаружили, что V8 часто попадал на медленный путь для `instanceof` ([v8:6971](http://crbug.com/v8/6971)), что вызывало замедление на 3–4 раза. Мы также нашли и устранили узкие места производительности в некоторых случаях присвоения свойств в форме `obj[name] = val`, где `obj` создавался с помощью `Object.create(null)`. В таких случаях V8 сходил с быстрого пути, несмотря на то, что мог использовать факт наличия у `obj` прототипа `null` ([v8:6985](http://crbug.com/v8/6985)). Эти и другие открытия, сделанные с помощью этого бенчмарка, улучшают V8 не только в Node.js, но и в Chrome.

Мы не только стремились сделать V8 быстрее, но и устраняли и вносили исправления в баги производительности в инструментах и библиотеках тестов, когда натыкались на них. Например, мы обнаружили ряд проблем производительности в [Babel](https://github.com/babel/babel), где паттерны кода, такие как

```js
value = items[items.length - 1];
```

приводили к доступу к свойству `"-1"`, так как код не проверял, пуст ли массив `items` заранее. Этот шаблон кода заставляет V8 использовать медленный путь из-за поиска `"-1"`, хотя слегка модифицированная, эквивалентная версия JavaScript работает гораздо быстрее. Мы помогли исправить эти проблемы в Babel ([babel/babel#6582](https://github.com/babel/babel/pull/6582), [babel/babel#6581](https://github.com/babel/babel/pull/6581) и [babel/babel#6580](https://github.com/babel/babel/pull/6580)). Мы также обнаружили и исправили баг, при котором Babel обращался за пределы длины строки ([babel/babel#6589](https://github.com/babel/babel/pull/6589)), что вызывало еще один медленный путь в V8. Кроме того, мы [оптимизировали чтение массивов и строк вне допустимых границ](https://twitter.com/bmeurer/status/926357262318305280) в V8. Мы с нетерпением ждем продолжения [сотрудничества с сообществом](https://twitter.com/rauchg/status/924349334346276864) по улучшению производительности этого важного сценария, не только в случае работы на V8, но и на других движках JavaScript, таких как ChakraCore.

Наше сильное внимание к производительности в реальных условиях, особенно к улучшению популярных нагрузок Node.js, демонстрируется постоянными улучшениями показателей V8 на тесте в последних выпусках:

![](/_img/web-tooling-benchmark/chart.svg)

С версии V8 v5.8, которая является последним выпуском V8 перед [переходом на архитектуру Ignition+TurboFan](/blog/launching-ignition-and-turbofan), показатель V8 на тесте рабочих инструментов улучшился примерно на **60%**.

За последние несколько лет команда V8 осознала, что ни один бенчмарк для JavaScript — даже хорошо продуманный и тщательно созданный — не должен использоваться как единственный показатель общей производительности движка JavaScript. Однако мы считаем, что новый **Web Tooling Benchmark** выделяет области производительности JavaScript, на которые стоит обратить внимание. Несмотря на название и исходную мотивацию, мы обнаружили, что набор тестов Web Tooling Benchmark является не только представительным для нагрузок инструментов, но и охватывает широкий спектр более сложных приложений на JavaScript, которые плохо тестируются бенчмарками, ориентированными на фронтенд, такими как Speedometer. Это ни в коем случае не замена Speedometer, а скорее дополняющий набор тестов.

Лучшая новость заключается в том, что, учитывая, что Web Tooling Benchmark построен на реальных нагрузках, мы ожидаем, что наши недавние улучшения в показателях тестов непосредственно приведут к повышению производительности разработчиков благодаря [уменьшению времени ожидания сборки](https://xkcd.com/303/). Многие из этих улучшений уже доступны в Node.js: на момент написания Node 8 LTS использует V8 v6.1, а Node 9 — V8 v6.2.

Последняя версия теста размещена по адресу [https://v8.github.io/web-tooling-benchmark/](https://v8.github.io/web-tooling-benchmark/).
