---
title: &apos;Дополнительный механизм RegExp без обратного отслеживания&apos;
author: &apos;Мартин Бидлингмайер&apos;
date: 2021-01-11
tags:
 - internals
 - RegExp
description: &apos;V8 теперь имеет дополнительный механизм RegExp, который служит резервным и предотвращает множество случаев катастрофического обратного отслеживания.&apos;
tweet: &apos;1348635270762139650&apos;
---
Начиная с версии v8.8, V8 поставляется с новым экспериментальным механизмом RegExp без обратного отслеживания (в дополнение к существующему [движку Irregexp](https://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html)), который гарантирует выполнение за линейное время относительно размера входной строки. Экспериментальный механизм доступен за флагами функций, упомянутыми ниже.

<!--truncate-->
![Время выполнения `/(a*)*b/.exec(&apos;a&apos;.repeat(n))` для n ≤ 100](/_img/non-backtracking-regexp/runtime-plot.svg)

Вот как вы можете настроить новый механизм RegExp:

- `--enable-experimental-regexp_engine-on-excessive-backtracks` включает резервный механизм без обратного отслеживания при избыточных обратных переходах.
- `--regexp-backtracks-before-fallback N` (по умолчанию N = 50 000) указывает, сколько обратных переходов считается «избыточными», то есть когда срабатывает резервный механизм.
- `--enable-experimental-regexp-engine` включает распознавание нестандартного флага `l` («линейный») для регулярных выражений, например `/(a*)*b/l`. Регулярные выражения, созданные с этим флагом, всегда выполняются новым механизмом; Irregexp вообще не используется. Если новый механизм RegExp не может обработать шаблон регулярного выражения с флагом `l`, то при создании выбрасывается исключение. Мы надеемся, что эта функция в какой-то момент может быть использована для повышения безопасности приложений, которые работают с регулярными выражениями для недоверенных данных. Пока функция остается экспериментальной, так как Irregexp в разы быстрее нового механизма для большинства распространенных шаблонов.

Резервный механизм не применяется ко всем шаблонам. Чтобы резервный механизм сработал, регулярное выражение должно:

- не содержать обратных ссылок,
- не содержать предварительных или последующих проверок,
- не содержать больших или глубоко вложенных конечных повторений, как, например, в `/a{200,500}/`, и
- не иметь флагов `u` (Unicode) или `i` (нечувствительность к регистру).

## Предыстория: катастрофическое обратное отслеживание

Сопоставление RegExp в V8 обрабатывается движком Irregexp. Irregexp компилирует регулярные выражения в специализированный родной код (или в [байткод](/blog/regexp-tier-up)) и, таким образом, чрезвычайно быстр для большинства шаблонов. Однако для некоторых шаблонов время выполнения Irregexp может возрастать экспоненциально к размеру входной строки. Пример выше, `/(a*)*b/.exec(&apos;a&apos;.repeat(100))`, не завершается в течение нашего жизненного времени, если его выполнит Irregexp.

Так что же здесь происходит? Irregexp — это движок *обратного отслеживания*. Когда сталкивается с выбором, как продолжить сопоставление, Irregexp полностью исследует первый альтернативный вариант, а затем возвращается назад, если необходимо, чтобы исследовать второй вариант. Например, рассмотрим сопоставление шаблона `/abc|[az][by][0-9]/` со строкой `&apos;ab3&apos;`. Здесь Irregexp сначала пытается сопоставить `/abc/` и терпит неудачу после второго символа. Затем он возвращается на два символа и успешно сопоставляет вторую альтернативу `/[az][by][0-9]/`. В шаблонах с квантификаторами, такими как `/(abc)*xyz/`, Irregexp должен выбирать после совпадения тела, сопоставлять ли тело снова или продолжать с оставшейся частью шаблона.

Попробуем понять, что происходит при сопоставлении `/(a*)*b/` с меньшей входной строкой, например, `&apos;aaa&apos;`. Этот шаблон содержит вложенные квантификаторы, так что мы просим Irregexp сопоставить *последовательность последовательностей* из `&apos;a&apos;`, а затем сопоставить `&apos;b&apos;`. Очевидно, что совпадения нет, так как входная строка не содержит `&apos;b&apos;`. Однако `/(a*)*/` сопоставляется, и делает это многими экспоненциально различными способами:

```js
&apos;aaa&apos;           &apos;aa&apos;, &apos;a&apos;           &apos;aa&apos;, &apos;&apos;
&apos;a&apos;, &apos;aa&apos;       &apos;a&apos;, &apos;a&apos;, &apos;a&apos;       &apos;a&apos;, &apos;a&apos;, &apos;&apos;
…
```

Irregexp изначально не может исключить, что неудача сопоставления заключительного `/b/` вызвана неправильным выбором способа сопоставления `/(a*)*/`, поэтому он вынужден проверить все варианты. Эта проблема известна как «экспоненциальное» или «катастрофическое» обратное отслеживание.

## Регулярные выражения как автоматы и байткод

Чтобы понять альтернативный алгоритм, который невосприимчив к катастрофическому обратному отслеживанию, нам нужно сделать короткий экскурс через [автоматы](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton). Каждое регулярное выражение эквивалентно автомату. Например, регулярное выражение `/(a*)*b/`, приведенное выше, соответствует следующему автомату:

![Автомат, соответствующий `/(a*)*b/`](/_img/non-backtracking-regexp/example-automaton.svg)

Обратите внимание, что автомат не определяется уникально шаблоном; тот, который вы видите выше, создается механическим процессом перевода и используется в новом механизме RegExp в V8 для `/(a*)*/`.
Необозначенные края представляют собой переходы с эпсилон: они не потребляют ввод. Переходы с эпсилон необходимы, чтобы размер автомата оставался примерно равным размеру шаблона. Пытаться наивно устранить переходы с эпсилон может привести к квадратичному увеличению числа переходов.
Переходы с эпсилон также позволяют построить автомат, соответствующий регулярному выражению, из следующих четырех базовых типов состояний:

![Регулярные выражения байткод инструкции](/_img/non-backtracking-regexp/state-types.svg)

Здесь мы классифицируем только переходы *из* состояния, в то время как переходы в состояние могут быть произвольными. Автоматы, построенные только из этих типов состояний, могут быть представлены как *байткод-программы*, где каждое состояние соответствует инструкции. Например, состояние с двумя переходами с эпсилон представлено как инструкция `FORK`.

## Алгоритм бэктрекинга

Давайте вернемся к алгоритму бэктрекинга, на котором основан Irregexp, и опишем его с точки зрения автоматов. Предположим, нам предоставлен массив байткода `code`, соответствующий шаблону, и нужно `проверить`, совпадает ли `input` с этим шаблоном. Предположим, что `code` выглядит примерно так:

```js
const code = [
  {opcode: &apos;FORK&apos;, forkPc: 4},
  {opcode: &apos;CONSUME&apos;, char: &apos;1&apos;},
  {opcode: &apos;CONSUME&apos;, char: &apos;2&apos;},
  {opcode: &apos;JMP&apos;, jmpPc: 6},
  {opcode: &apos;CONSUME&apos;, char: &apos;a&apos;},
  {opcode: &apos;CONSUME&apos;, char: &apos;b&apos;},
  {opcode: &apos;ACCEPT&apos;}
];
```

Этот байткод соответствует шаблону (sticky) `/12|ab/y`. Поле `forkPc` инструкции `FORK` является индексом («программным счетчиком») альтернативного состояния/инструкции, в которую мы можем перейти, и аналогично для `jmpPc`. Индексы начинаются с нуля. Алгоритм бэктрекинга теперь можно реализовать на JavaScript следующим образом.

```js
let ip = 0; // Позиция ввода.
let pc = 0; // Программный счетчик: индекс следующей инструкции.
const stack = []; // Стэк для бэктрекинга.
while (true) {
  const inst = code[pc];
  switch (inst.opcode) {
    case &apos;CONSUME&apos;:
      if (ip < input.length && input[ip] === inst.char) {
        // Ввод соответствует ожидаемому: продолжаем.
        ++ip;
        ++pc;
      } else if (stack.length > 0) {
        // Неправильный символ ввода, но можем откатиться.
        const back = stack.pop();
        ip = back.ip;
        pc = back.pc;
      } else {
        // Неправильный символ, откат невозможен.
        return false;
      }
      break;
    case &apos;FORK&apos;:
      // Сохраняем альтернативу для последующего бэктрекинга.
      stack.push({ip: ip, pc: inst.forkPc});
      ++pc;
      break;
    case &apos;JMP&apos;:
      pc = inst.jmpPc;
      break;
    case &apos;ACCEPT&apos;:
      return true;
  }
}
```

Эта реализация зацикливается бесконечно, если программа байткода содержит циклы, которые не потребляют никакой символ, то есть если автомат содержит цикл, состоящий только из переходов с эпсилон. Эту проблему можно решить с помощью предварительного анализа одного символа. Irregexp гораздо сложнее, чем эта простая реализация, но в конечном счете основан на том же алгоритме.

## Алгоритм без бэктрекинга

Алгоритм бэктрекинга соответствует *поиску в глубину* автомата: мы всегда полностью исследуем первую альтернативу инструкции `FORK`, а затем возвращаемся ко второй альтернативе, если это необходимо. Альтернативный подход — алгоритм без бэктрекинга, который, неудивительно, основан на *поиске в ширину* автомата. Здесь мы учитываем все альтернативы одновременно, в шагах, соответствующих текущей позиции в строке ввода. Таким образом, мы поддерживаем список текущих состояний, а затем продвигаем все состояния, совершая переходы, соответствующие каждому символу ввода. Важно, чтобы из списка текущих состояний удалялись дубли.

Простая реализация на JavaScript выглядит примерно так:

```js
// Позиция ввода.
let ip = 0;
// Список текущих значений pc или `&apos;ACCEPT&apos;`, если был найден соответствующий элемент. Мы начинаем с
// pc 0 и следуем переходам с эпсилон.
let pcs = followEpsilons([0]);

while (true) {
  // Мы закончили, если был найден соответствующий элемент…
  if (pcs === &apos;ACCEPT&apos;) return true;
  // …или если мы исчерпали строку ввода.
  if (ip >= input.length) return false;

  // Продолжаем только с теми pc, которые CONSUME корректный символ.
  pcs = pcs.filter(pc => code[pc].char === input[ip]);
  // Продвигаем оставшиеся pc к следующей инструкции.
  pcs = pcs.map(pc => pc + 1);
  // Следуем переходам с эпсилон.
  pcs = followEpsilons(pcs);

  ++ip;
}
```

Здесь `followEpsilons` — это функция, которая принимает список программных счетчиков и вычисляет список программных счетчиков на инструкциях `CONSUME`, которые могут быть достигнуты через переходы с эпсилон (то есть только используя FORK и JMP). Возвращенный список не должен содержать дублей. Если можно достигнуть инструкции `ACCEPT`, функция возвращает `&apos;ACCEPT&apos;`. Она может быть реализована так:

```js
function followEpsilons(pcs) {
  // Набор pc, которые мы видели до сих пор.
  const visitedPcs = new Set();
  const result = [];

  while (pcs.length > 0) {
    const pc = pcs.pop();

    // Мы можем игнорировать pc, если видели его раньше.
    if (visitedPcs.has(pc)) continue;
    visitedPcs.add(pc);

    const inst = code[pc];
    switch (inst.opcode) {
      case &apos;CONSUME&apos;:
        result.push(pc);
        break;
      case &apos;FORK&apos;:
        pcs.push(pc + 1, inst.forkPc);
        break;
      case &apos;JMP&apos;:
        pcs.push(inst.jmpPc);
        break;
      case &apos;ACCEPT&apos;:
        return &apos;ACCEPT&apos;;
    }
  }

  return result;
}
```

Поскольку благодаря устранению дубликатов с помощью множества `visitedPcs` мы знаем, что каждый программный счетчик проверяется только один раз в `followEpsilons`. Это гарантирует, что список `result` не содержит дубликатов, а время выполнения `followEpsilons` ограничено размером массива `code`, то есть размером шаблона. `followEpsilons` вызывается максимум `input.length` раз, поэтому общее время выполнения сопоставления RegExp ограничено `𝒪(pattern.length * input.length)`.

Алгоритм без обратного отслеживания можно расширить для поддержки большинства функций JavaScript RegExp, например, границ слов или вычисления границ (под)совпадений. К сожалению, обратные ссылки, просмотр вперед и назад не могут быть поддержаны без серьезных изменений, которые изменяют асимптотическую сложность в худшем случае.

Новый механизм RegExp в V8 основан на этом алгоритме и его реализации в библиотеках [re2](https://github.com/google/re2) и [Rust regex](https://github.com/rust-lang/regex). Алгоритм обсуждается гораздо более подробно, чем здесь, в отличной [серии блогов](https://swtch.com/~rsc/regexp/) Русса Кокса, который также является оригинальным автором библиотеки re2.
