---
title: 'Релиз V8 версии 6.8'
author: 'Команда V8'
date: 2018-06-21 13:33:37
tags:
  - релиз
description: 'Версия V8 6.8 обладает уменьшенным потреблением памяти и несколькими улучшениями производительности.'
tweet: '1009753739060826112'
---
Каждые шесть недель мы создаем новую ветку V8 в рамках нашего [процесса выпуска](/docs/release-process). Каждая версия отделяется от главной ветки Git V8 непосредственно перед бета-версией Chrome. Сегодня мы рады объявить о создании новой ветки [V8 версии 6.8](https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/6.8), которая находится в бета-версии до выпуска совместно с Chrome 68 Stable через несколько недель. В V8 v6.8 множество различных улучшений для разработчиков. В этом посте представлена подборка ключевых моментов в преддверии релиза.

<!--truncate-->
## Память

Функции JavaScript неоправданно сохраняли внешние функции и их метаданные (известные как `SharedFunctionInfo` или `SFI`). Особенно в коде с большим количеством функций, полагающихся на кратковременно живущие IIFE, это могло приводить к утечкам памяти. До этого изменения активный `Context` (т.е. представление активации функции в куче) сохранял `SFI` функции, создавшей этот контекст:

![](/_img/v8-release-68/context-jsfunction-before.svg)

Сделав так, чтобы `Context` указывал на объект `ScopeInfo`, содержащий сжатую информацию, необходимую для отладки, мы смогли разорвать зависимость от `SFI`.

![](/_img/v8-release-68/context-jsfunction-after.svg)

Мы уже наблюдали улучшение памяти V8 на 3% на мобильных устройствах для набора из 10 популярных страниц.

Параллельно мы уменьшили потребление памяти самими `SFI`, удалив ненужные поля или сжав их, где это было возможно, и уменьшив их размер примерно на 25%, с дальнейшими сокращениями в будущих версиях. Мы отметили, что `SFI` занимают от 2% до 6% памяти V8 на типичных веб-сайтах даже после их отделения от контекста, так что вы должны заметить улучшение памяти в коде с большим числом функций.

## Производительность

### Улучшения деструктуризации массивов

Оптимизирующий компилятор не генерировал идеальный код для деструктуризации массивов. Например, обмен переменных с помощью `[a, b] = [b, a]` раньше был в два раза медленнее, чем `const tmp = a; a = b; b = tmp`. После того как мы разблокировали анализ выхода, чтобы исключить все временные выделения, деструктуризация массивов с временным массивом стала такой же быстрой, как последовательность присваиваний.

### Улучшения `Object.assign`

До сих пор `Object.assign` имел быструю реализацию, написанную на C++. Это означало, что при каждом вызове `Object.assign` необходимо было переходить через границу между JavaScript и C++. Очевидным способом улучшения производительности встроенной функции было добавление быстрого пути на стороне JavaScript. У нас было два варианта: реализовать ее как встроенную функцию на JavaScript (что в данном случае привело бы к избыточным накладным расходам) или использовать [технологию CodeStubAssembler](/blog/csa) (которая предлагает большую гибкость). Мы выбрали второе решение. Новая реализация `Object.assign` улучшает результат работы [Speedometer2/React-Redux примерно на 15%, увеличивая общий результат Speedometer 2 на 1,5%](https://chromeperf.appspot.com/report?sid=d9ea9a2ae7cd141263fde07ea90da835cf28f5c87f17b53ba801d4ac30979558&start_rev=550155&end_rev=552590).

### Улучшения `TypedArray.prototype.sort`

`TypedArray.prototype.sort` имеет два пути: быстрый путь, который используется, когда пользователь не предоставляет функцию сравнения, и медленный путь для остальных случаев. До сих пор медленный путь использовал реализацию для `Array.prototype.sort`, которая выполняет гораздо больше, чем требуется для сортировки `TypedArray`. В V8 v6.8 медленный путь был заменен реализацией в [CodeStubAssembler](/blog/csa). (Не напрямую CodeStubAssembler, а доменно-специфическим языком, построенным на основе CodeStubAssembler).

Производительность сортировки `TypedArray` без функции сравнения осталась прежней, в то время как при использовании функции сравнения наблюдается ускорение до 2,5 раз.

![](/_img/v8-release-68/typedarray-sort.svg)

## WebAssembly

В V8 v6.8 вы можете начать использовать [проверку границ на основе ловушек](https://docs.google.com/document/d/17y4kxuHFrVxAiuCP_FFtFA2HP5sNPsCD10KEx17Hz6M/edit) на платформах Linux x64. Эта оптимизация управления памятью значительно улучшает скорость выполнения WebAssembly. Она уже используется в Chrome 68, а в будущем будет постепенно поддерживаться на других платформах.

## API V8

Используйте команду `git log branch-heads/6.7..branch-heads/6.8 include/v8.h`, чтобы получить список изменений API.

Разработчики с [активной копией источников V8](/docs/source-code#using-git) могут использовать команду `git checkout -b 6.8 -t branch-heads/6.8`, чтобы поэкспериментировать с новыми функциями в V8 v6.8. Альтернативно, вы можете [подписаться на бета-канал Chrome](https://www.google.com/chrome/browser/beta.html) и скоро попробовать новые функции самостоятельно.
