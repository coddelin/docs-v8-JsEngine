---
title: 'Есть `Math.random()`, а затем есть `Math.random()`'
author: 'Ян Гуо ([@hashseed](https://twitter.com/hashseed)), инженер-программист и дизайнер костей'
avatars:
  - 'yang-guo'
date: 2015-12-17 13:33:37
tags:
  - ECMAScript
  - internals
description: 'Реализация Math.random в V8 теперь использует алгоритм, называемый xorshift128+, улучшая случайность по сравнению со старой реализацией MWC1616.'
---
> `Math.random()` возвращает значение `Number` с положительным знаком, большее или равное `0`, но меньшее `1`, выбираемое случайным или псевдослучайным образом с приблизительно равномерным распределением в этом диапазоне, используя алгоритм или стратегию, зависящие от реализации. Эта функция не принимает аргументов.

<!--truncate-->
— _[ES 2015, раздел 20.2.2.27](http://tc39.es/ecma262/#sec-math.random)_

`Math.random()` — это самый известный и часто используемый источник случайности в JavaScript. В V8 и большинстве других движков JavaScript он реализован с использованием [генератора псевдослучайных чисел](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) (PRNG). Как и все PRNG, случайное число выводится из внутреннего состояния, которое изменяется фиксированным алгоритмом для каждого нового случайного числа. Таким образом, для заданного начального состояния последовательность случайных чисел является детерминированной. Поскольку размер битов n внутреннего состояния ограничен, числа, генерируемые PRNG, в конечном итоге будут повторяться. Верхняя граница длины периода этого [цикла перестановки](https://en.wikipedia.org/wiki/Cyclic_permutation) составляет 2<sup>n</sup>.

Существует много разных алгоритмов PRNG; среди самых известных — [Mersenne-Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) и [LCG](https://en.wikipedia.org/wiki/Linear_congruential_generator). У каждого из них есть свои особенности, преимущества и недостатки. В идеале он должен использовать как можно меньше памяти для начального состояния, быть быстрым в выполнении, иметь большую длину периода и предлагать высококачественное случайное распределение. Хотя использование памяти, производительность и длину периода легко измерить или рассчитать, качество определить сложнее. За статистическими тестами для проверки качества случайных чисел стоит много математики. Фактический стандарт набора тестов PRNG, [TestU01](http://simul.iro.umontreal.ca/testu01/tu01.html), реализует многие из этих тестов.

До [конца 2015 года](https://github.com/v8/v8/blob/ceade6cf239e0773213d53d55c36b19231c820b5/src/js/math.js#L143) (до версии 4.9.40) выбор PRNG для V8 был MWC1616 (умножение с переносом, соединяя две части по 16 бит). Он использует 64 бита внутреннего состояния и выглядит примерно так:

```cpp
uint32_t state0 = 1;
uint32_t state1 = 2;
uint32_t mwc1616() {
  state0 = 18030 * (state0 & 0xFFFF) + (state0 >> 16);
  state1 = 30903 * (state1 & 0xFFFF) + (state1 >> 16);
  return state0 << 16 + (state1 & 0xFFFF);
}
```

Значение 32-бита затем преобразуется в число с плавающей точкой между 0 и 1 в соответствии с спецификацией.

MWC1616 использует мало памяти и довольно быстро вычисляется, но, к сожалению, предлагает низкое качество:

- Количество случайных значений, которые он может генерировать, ограничено 2<sup>32</sup>, в отличие от 2<sup>52</sup> чисел между 0 и 1, которые может представлять двойная точность с плавающей точкой.
- Более значительная верхняя часть результата почти полностью зависит от значения state0. Длина периода составляла бы максимум 2<sup>32</sup>, но вместо нескольких больших циклов перестановки существует множество коротких. При плохо выбранном начальном состоянии длина цикла могла бы составить менее 40 миллионов.
- Он не проходит многие статистические тесты в наборе TestU01.

Нам сообщили об этом [проблеме](https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d), и, разобравшись с проблемой и проведя небольшое исследование, мы решили переосмыслить реализацию `Math.random`, основываясь на алгоритме [xorshift128+](http://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf). Он использует 128 бит внутреннего состояния, имеет длину периода 2<sup>128</sup> - 1 и проходит все тесты из набора TestU01.

Реализация была [внедрена в V8 v4.9.41.0](https://github.com/v8/v8/blob/085fed0fb5c3b0136827b5d7c190b4bd1c23a23e/src/base/utils/random-number-generator.h#L102) всего через несколько дней после того, как мы узнали о проблеме. Она стала доступна с Chrome 49. Как [Firefox](https://bugzilla.mozilla.org/show_bug.cgi?id=322529#c99), так и [Safari](https://bugs.webkit.org/show_bug.cgi?id=151641) также перешли на xorshift128+.

В V8 v7.1 реализация была снова скорректирована [CL](https://chromium-review.googlesource.com/c/v8/v8/+/1238551/5), опираясь только на state0. Дополнительные детали реализации можно найти в [исходном коде](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/base/utils/random-number-generator.h;l=119?q=XorShift128&sq=&ss=chromium).

Однако не заблуждайтесь: хотя xorshift128+ является огромным улучшением по сравнению с MWC1616, он все же не является [криптографически безопасным](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator). Для таких случаев использования, как хеширование, генерация подписей и шифрование/дешифрование, обычные генераторы псевдослучайных чисел не подходят. API веб-криптографии вводит метод [`window.crypto.getRandomValues`](https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues), который возвращает криптографически безопасные случайные значения, но за счет снижения производительности.

Пожалуйста, имейте в виду: если вы увидите области, которые можно улучшить в V8 и Chrome, даже те, которые — как эта — не напрямую влияют на соблюдение спецификаций, стабильность или безопасность, пожалуйста, сообщите нам [об этой проблеме в нашем трекере ошибок](https://bugs.chromium.org/p/v8/issues/entry?template=Defect%20report%20from%20user).
