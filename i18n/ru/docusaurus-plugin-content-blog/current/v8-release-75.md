---
title: "Релиз V8 версии 7.5"
author: "Дэн Элфик, бич устаревшего кода"
avatars:
  - "dan-elphick"
date: 2019-05-16 15:00:00
tags:
  - release
description: "V8 v7.5 включает в себя имплицитное кеширование артефактов компиляции WebAssembly, массовые операции с памятью, числовые разделители в JavaScript и многое другое!"
tweet: "1129073370623086593"
---
Каждые шесть недель мы создаем новую ветвь V8 в рамках нашего [процесса выпуска](/docs/release-process). Каждая версия ветвится от Git master V8 непосредственно перед очередной бета-версией Chrome. Сегодня мы рады объявить о нашей новейшей ветви, [V8 версии 7.5](https://chromium.googlesource.com/v8/v8.git/+log/branch-heads/7.5), которая находится в стадии бета-тестирования до ее выпуска в стабильной версии Chrome 75 через несколько недель. V8 v7.5 наполнен множеством полезных обновлений для разработчиков. В этом посте представлен предварительный обзор некоторых важных изменений.

<!--truncate-->
## WebAssembly

### Имплицитное кеширование

Мы планируем внедрить имплицитное кеширование артефактов компиляции WebAssembly в Chrome 75. Это означает, что пользователи, которые заходят на одну и ту же страницу повторно, больше не должны компилировать уже просмотренные модули WebAssembly. Вместо этого они загружаются из кеша. Это работает аналогично [кешированию JavaScript-кода в Chromium](/blog/code-caching-for-devs).

Если вы хотите использовать похожую функцию в вашем окружении V8, пожалуйста, обратите внимание на реализацию в Chromium.

### Массовые операции с памятью

[Предложение о массовых операциях с памятью](https://github.com/webassembly/bulk-memory-operations) добавляет новые инструкции в WebAssembly для обновления больших областей памяти или таблиц.

`memory.copy` копирует данные из одной области в другую, даже если области пересекаются (как `memmove` в C). `memory.fill` заполняет область заданным байтом (аналогично `memset` в C). Подобно `memory.copy`, `table.copy` копирует элементы в таблице из одной области в другую, даже если они пересекаются.

```wasm
;; Копировать 500 байт из источника 1000 в назначение 0.
(memory.copy (i32.const 0) (i32.const 1000) (i32.const 500))

;; Заполнить 1000 байт, начиная с адреса 100, значением `123`.
(memory.fill (i32.const 100) (i32.const 123) (i32.const 1000))

;; Копировать 10 элементов таблицы из источника 5 в назначение 15.
(table.copy (i32.const 15) (i32.const 5) (i32.const 10))
```

Это предложение также предоставляет возможность копировать постоянную область в линейную память или таблицу. Для этого сначала нужно определить "пассивный" сегмент. В отличие от "активных" сегментов, эти сегменты не инициализируются во время инстанцирования модуля. Вместо этого они могут быть скопированы в память или область таблицы, используя инструкции `memory.init` и `table.init`.

```wasm
;; Определить пассивный сегмент данных.
(data $hello passive "Hello WebAssembly")

;; Скопировать "Hello" в память по адресу 10.
(memory.init (i32.const 10) (i32.const 0) (i32.const 5))

;; Скопировать "WebAssembly" в память по адресу 1000.
(memory.init (i32.const 1000) (i32.const 6) (i32.const 11))
```

## Числовые разделители в JavaScript

Большие числовые литералы сложно быстро воспринимать, особенно если они содержат много повторяющихся цифр:

```js
1000000000000
   1019436871.42
```

Для улучшения читаемости [новая функция языка JavaScript](/features/numeric-separators) позволяет использовать подчеркивания в качестве разделителей в числовых литералах. Теперь вышеуказанное можно записать с разделением цифр по тысячам, например:

```js
1_000_000_000_000
    1_019_436_871.42
```

Теперь легче понять, что первое число — триллион, а второе — порядка 1 миллиарда.

Для дополнительных примеров и информации о числовых разделителях см. [наш пояснительный материал](/features/numeric-separators).

## Производительность

### Потоковая обработка скриптов прямо из сети

Начиная с Chrome 75, V8 может обрабатывать потоковые скрипты напрямую из сети в потоковый парсер, не ожидая главного потока Chrome.

Хотя в предыдущих версиях Chrome уже были доступна потоковая обработка и компиляция, исходные данные скриптов из сети всегда сначала проходили через главный поток Chrome, прежде чем передавались в потоковый обработчик, по историческим причинам. Это означало, что потоковый парсер часто ожидал данные, уже полученные из сети, но еще не переданные в потоковую задачу, так как они были заблокированы другими операциями на главном потоке (такими как синтаксический анализ HTML, макетирование или выполнение другого JavaScript).

![Заблокированные фоновые задачи анализа в Chrome 74 и более ранних версиях](/_img/v8-release-75/before.jpg)

В Chrome 75 мы напрямую подключили "канал данных" из сети к V8, позволяя читать сетевые данные напрямую во время потокового анализа, избегая зависимости от главного потока.

![В Chrome 75+ фоновые задачи анализа больше не блокируются активностью на главном потоке.](/_img/v8-release-75/after.jpg)

Это позволяет нам завершить потоковые компиляции раньше, улучшая время загрузки страниц с использованием потоковой компиляции, а также уменьшая количество параллельных (но задержанных) задач потокового анализа, что снижает потребление памяти.

## V8 API

Пожалуйста, используйте `git log branch-heads/7.4..branch-heads/7.5 include/v8.h`, чтобы получить список изменений API.

Разработчики с [активной копией V8](/docs/source-code#using-git) могут использовать `git checkout -b 7.5 -t branch-heads/7.5`, чтобы протестировать новые возможности V8 версии 7.5. Кроме того, вы можете [подписаться на бета-канал Chrome](https://www.google.com/chrome/browser/beta.html) и скоро попробовать новые функции самостоятельно.
