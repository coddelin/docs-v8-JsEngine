---
title: 'Retiring Octane'
author: 'the V8 team'
date: 2017-04-12 13:33:37
tags:
  - benchmarks
description: 'The V8 team believes that it is time to retire Octane as a recommended benchmark.'
---
The history of JavaScript benchmarks is a story of constant evolution. As the web expanded from simple documents to dynamic client-side applications, new JavaScript benchmarks were created to measure workloads that became important for new use cases. This constant change has given individual benchmarks finite lifespans. As web browser and virtual machine (VM) implementations begin to over-optimize for specific test cases, benchmarks themselves cease to become effective proxies for their original use cases. One of the first JavaScript benchmarks, [SunSpider](https://webkit.org/perf/sunspider/sunspider.html), provided early incentives for shipping fast optimizing compilers. However, as VM engineers uncovered the [limitations of microbenchmarks](https://blog.mozilla.org/nnethercote/2014/06/16/a-browser-benchmarking-manifesto/) and found new ways to [optimize](https://benediktmeurer.de/2016/12/16/the-truth-about-traditional-javascript-benchmarks/#the-notorious-sunspider-examples) [around](https://bugzilla.mozilla.org/show_bug.cgi?id=787601) SunSpider’s [limitations](https://bugs.webkit.org/show_bug.cgi?id=63864), the browser community [retired](https://trac.webkit.org/changeset/187526/webkit) SunSpider as a recommended benchmark.

## The genesis of Octane

Designed to mitigate some of the weaknesses of early microbenchmarks, the [Octane benchmark suite](https://developers.google.com/octane/) was first released in 2012. It evolved from an earlier set of simple [V8 test cases](http://www.netchain.com/Tools/v8/) and became a common benchmark for general web performance. Octane consists of 17 different tests, which were designed to cover a variety of different workloads, ranging from Martin Richards’ kernel simulation test to a version of [Microsoft’s TypeScript compiler](http://www.typescriptlang.org/) compiling itself. The contents of Octane represented the prevailing wisdom around measuring JavaScript performance at the time of its creation.

## Diminishing returns and over-optimization

In the first few years after its release, Octane provided a unique value to the JavaScript VM ecosystem. It allowed engines, including V8, to optimize their performance for a class of applications that stressed peak performance. These CPU-intensive workloads were initially underserviced by VM implementations. Octane helped engine developers deliver optimizations that allowed computationally-heavy applications to reach speeds that made JavaScript a viable alternative to C++ or Java. In addition, Octane drove improvements in garbage collection which helped web browsers avoid long or unpredictable pauses.

By 2015, however, most JavaScript implementations had implemented the compiler optimizations needed to achieve high scores on Octane. Striving for even higher benchmark scores on Octane translated into increasingly-marginal improvements in the performance of real web pages. Investigations into the execution profile of running [Octane versus loading common websites](/blog/real-world-performance) (such as Facebook, Twitter, or Wikipedia) revealed that the benchmark doesn’t exercise V8’s [parser](https://medium.com/dev-channel/javascript-start-up-performance-69200f43b201#.7v8b4jylg) or the browser [loading stack](https://medium.com/reloading/toward-sustainable-loading-4760957ee46f#.muk9kzxmb) the way real-world code does. Moreover, the style of Octane’s JavaScript doesn’t match the idioms and patterns employed by most modern frameworks and libraries (not to mention transpiled code or newer ES2015+ language features). This means that using Octane to measure V8 performance didn’t capture important use cases for the modern web, such as loading frameworks quickly, supporting large applications with new patterns of state management, or ensuring that ES2015+ features [are as fast as their ES5 equivalents](/blog/high-performance-es2015).

In addition, we began to notice that JavaScript optimizations which eked out higher Octane scores often had a detrimental effect on real-world scenarios. Octane encourages aggressive inlining to minimize the overhead of function calls, but inlining strategies that are tailored to Octane have led to regressions from increased compilation costs and higher memory usage in real-world use cases. Even when an optimization may be genuinely useful in the real-world, as is the case with [dynamic pretenuring](http://dl.acm.org/citation.cfm?id=2754181), chasing higher Octane scores can result in developing overly-specific heuristics which have little effect or even degrade performance in more generic cases. We found that Octane-derived pretenuring heuristics led to performance degradations in [modern frameworks such as Ember](https://bugs.chromium.org/p/v8/issues/detail?id=3665). The `instanceof` operator was another example of an optimization tailored to a narrow set of Octane-specific cases that led to [significant regressions in Node.js applications](https://github.com/nodejs/node/issues/9634).

Another problem is that over time, small bugs in Octane become a target for optimizations themselves. For example, in the Box2DWeb benchmark, taking advantage of [a bug](http://crrev.com/1355113002) where two objects were compared using the `<` and `>=` operators gave a ~15% performance boost on Octane. Unfortunately, this optimization had no effect in the real world and complicates more general types of comparison optimizations. Octane sometimes even negatively penalizes real-world optimizations: engineers working on other VMs [have noticed](https://bugzilla.mozilla.org/show_bug.cgi?id=1162272) that Octane seems to penalize lazy parsing, a technique that helps most real websites load faster given the amount of dead code frequently found in the wild.

## Beyond Octane and other synthetic benchmarks

These examples are just some of the many optimizations which increased Octane scores to the detriment of running real websites. Unfortunately, similar issues exist in other static or synthetic benchmarks, including Kraken and JetStream. Simply put, such benchmarks are insufficient methods of measuring real-world speed and create incentives for VM engineers to over-optimize narrow use cases and under-optimize generic cases, slowing down JavaScript code in the wild.

Given the plateau in scores across most JS VMs and the increasing conflict between optimizing for specific Octane benchmarks rather than implementing speedups for a broader range of real-world code, we believe that it is time to retire Octane as a recommended benchmark.

Octane enabled the JS ecosystem to make large gains in computationally-expensive JavaScript. The next frontier, however, is improving the performance of [real web pages](/blog/real-world-performance), modern libraries, [frameworks](http://stateofjs.com/2016/frontend/), ES2015+ [language features](/blog/high-performance-es2015), new patterns of [state management](http://redux.js.org/), [immutable object allocation](https://facebook.github.io/immutable-js/), and [module](https://webpack.github.io/) [bundling](http://browserify.org/). Since V8 runs in many environments, including server side in Node.js, we are also investing time in understanding real-world Node applications and measuring server-side JavaScript performance through workloads such as [AcmeAir](https://github.com/acmeair/acmeair-nodejs).

Check back here for more posts about [improvements in our measurement methodology](/blog/real-world-performance) and [new workloads](/blog/optimizing-v8-memory) that better represent real-world performance. We are excited to continue pursuing the performance that matters most to users and developers!
