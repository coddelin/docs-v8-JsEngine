---
title: &apos;Trie stable `Array.prototype.sort`&apos;
author: &apos;Mathias Bynens ([@mathias](https://twitter.com/mathias))&apos;
avatars:
  - &apos;mathias-bynens&apos;
date: 2019-07-02
tags:
  - ECMAScript
  - ES2019
  - io19
description: &apos;Array.prototype.sort est maintenant garanti d&apos;√™tre stable.&apos;
tweet: &apos;1146067251302244353&apos;
---
Disons que vous avez un tableau de chiens, o√π chaque chien a un nom et une note. (Si cet exemple vous semble bizarre, sachez qu&apos;il existe un compte Twitter qui se sp√©cialise exactement l√†-dedans‚Ä¶ Ne demandez pas !)

```js
// Notez comment le tableau est pr√©-tri√© par ordre alphab√©tique par `name`.
const doggos = [
  { name: &apos;Abby&apos;,   rating: 12 },
  { name: &apos;Bandit&apos;, rating: 13 },
  { name: &apos;Choco&apos;,  rating: 14 },
  { name: &apos;Daisy&apos;,  rating: 12 },
  { name: &apos;Elmo&apos;,   rating: 12 },
  { name: &apos;Falco&apos;,  rating: 13 },
  { name: &apos;Ghost&apos;,  rating: 14 },
];
// Triez les chiens par `rating` en ordre d√©croissant.
// (Cela met √† jour `doggos` en place.)
doggos.sort((a, b) => b.rating - a.rating);
```

<!--truncate-->
Le tableau est pr√©-tri√© par ordre alphab√©tique par nom. Pour trier par note √† la place (afin d&apos;obtenir les chiens les mieux not√©s en premier), nous utilisons `Array#sort`, en passant un callback personnalis√© qui compare les notes. Voici le r√©sultat que vous attendriez probablement :

```js
[
  { name: &apos;Choco&apos;,  rating: 14 },
  { name: &apos;Ghost&apos;,  rating: 14 },
  { name: &apos;Bandit&apos;, rating: 13 },
  { name: &apos;Falco&apos;,  rating: 13 },
  { name: &apos;Abby&apos;,   rating: 12 },
  { name: &apos;Daisy&apos;,  rating: 12 },
  { name: &apos;Elmo&apos;,   rating: 12 },
]
```

Les chiens sont tri√©s par note, mais √† l&apos;int√©rieur de chaque note, ils sont toujours tri√©s par ordre alphab√©tique par nom. Par exemple, Choco et Ghost ont la m√™me note de 14, mais Choco appara√Æt avant Ghost dans le r√©sultat du tri, car c&apos;est l&apos;ordre qu&apos;ils avaient dans le tableau original √©galement.

Pour obtenir ce r√©sultat cependant, le moteur JavaScript ne peut pas utiliser _n&apos;importe quel_ algorithme de tri ‚Äî il doit s&apos;agir d&apos;un tri dit ¬´ stable ¬ª. Pendant longtemps, la sp√©cification JavaScript ne n√©cessitait pas la stabilit√© du tri pour `Array#sort`, et laissait plut√¥t cela √† l&apos;impl√©mentation. Et parce que ce comportement n&apos;√©tait pas sp√©cifi√©, vous pouviez √©galement obtenir ce r√©sultat de tri, o√π Ghost appara√Æt soudainement avant Choco :

```js
[
  { name: &apos;Ghost&apos;,  rating: 14 }, // üò¢
  { name: &apos;Choco&apos;,  rating: 14 }, // üò¢
  { name: &apos;Bandit&apos;, rating: 13 },
  { name: &apos;Falco&apos;,  rating: 13 },
  { name: &apos;Abby&apos;,   rating: 12 },
  { name: &apos;Daisy&apos;,  rating: 12 },
  { name: &apos;Elmo&apos;,   rating: 12 },
]
```

Autrement dit, les d√©veloppeurs JavaScript ne pouvaient pas compter sur la stabilit√© des tris. En pratique, la situation √©tait encore plus frustrante, car certains moteurs JavaScript utilisaient un tri stable pour les tableaux courts et un tri instable pour les tableaux plus grands. Cela √©tait vraiment d√©routant, car les d√©veloppeurs testaient leur code, voyaient un r√©sultat stable, mais obtenaient soudainement un r√©sultat instable en production lorsque le tableau √©tait l√©g√®rement plus grand.

Mais il y a de bonnes nouvelles. Nous [avons propos√© une modification de la sp√©cification](https://github.com/tc39/ecma262/pull/1340) qui rend `Array#sort` stable, et elle a √©t√© accept√©e. Tous les principaux moteurs JavaScript impl√©mentent maintenant un tri stable via `Array#sort`. C&apos;est juste une chose de moins √† laquelle les d√©veloppeurs JavaScript doivent s&apos;inqui√©ter. Cool !

(Oh, et [nous avons fait la m√™me chose pour les `TypedArray`s](https://github.com/tc39/ecma262/pull/1433) : ce tri est √©galement stable maintenant.)

:::note
**Note :** Bien que la stabilit√© soit maintenant requise par la sp√©cification, les moteurs JavaScript sont toujours libres d&apos;impl√©menter l&apos;algorithme de tri de leur choix. [V8 utilise Timsort](/blog/array-sort#timsort), par exemple. La sp√©cification ne mandate aucun algorithme de tri en particulier.
:::

## Support de fonctionnalit√©

### Trie stable `Array.prototype.sort`

<feature-support chrome="70 /blog/v8-release-70#javascript-language-features"
                 firefox="oui"
                 safari="oui"
                 nodejs="12 https://twitter.com/mathias/status/1120700101637353473"
                 babel="oui https://github.com/zloirock/core-js#ecmascript-array"></feature-support>

### Trie stable `%TypedArray%.prototype.sort`

<feature-support chrome="74 https://bugs.chromium.org/p/v8/issues/detail?id=8567"
                 firefox="67 https://bugzilla.mozilla.org/show_bug.cgi?id=1290554"
                 safari="oui"
                 nodejs="12 https://twitter.com/mathias/status/1120700101637353473"
                 babel="oui https://github.com/zloirock/core-js#ecmascript-typed-arrays"></feature-support>
