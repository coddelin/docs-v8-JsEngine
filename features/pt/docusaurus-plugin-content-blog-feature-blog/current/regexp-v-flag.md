---
title: 'Flag `v` do RegExp com nota√ß√£o de conjunto e propriedades de strings'
author: 'Mark Davis ([@mark_e_davis](https://twitter.com/mark_e_davis)), Markus Scherer, e Mathias Bynens ([@mathias](https://twitter.com/mathias))'
avatars:
  - 'mark-davis'
  - 'markus-scherer'
  - 'mathias-bynens'
date: 2022-06-27
tags:
  - ECMAScript
description: 'A nova flag `v` do RegExp habilita o modo `unicodeSets`, desbloqueando suporte para classes de caracteres estendidas, incluindo propriedades Unicode de strings, nota√ß√£o de conjuntos e correspond√™ncia melhorada para mai√∫sculas e min√∫sculas.'
tweet: '1541419838513594368'
---
JavaScript suporta express√µes regulares desde o ECMAScript 3 (1999). Dezesseis anos depois, o ES2015 introduziu [modo Unicode (a flag `u`)](https://mathiasbynens.be/notes/es6-unicode-regex), [modo sticky (a flag `y`)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky#description), e [o getter `RegExp.prototype.flags`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/flags). Tr√™s anos depois, o ES2018 introduziu [modo `dotAll` (a flag `s`)](https://mathiasbynens.be/notes/es-regexp-proposals#dotAll), [afirma√ß√µes lookbehind](https://mathiasbynens.be/notes/es-regexp-proposals#lookbehinds), [grupos de captura nomeados](https://mathiasbynens.be/notes/es-regexp-proposals#named-capture-groups), e [escapes de propriedades de caracteres Unicode](https://mathiasbynens.be/notes/es-unicode-property-escapes). E no ES2020, [`String.prototype.matchAll`](https://v8.dev/features/string-matchall) tornou mais f√°cil trabalhar com express√µes regulares. As express√µes regulares do JavaScript evolu√≠ram bastante e continuam melhorando.

<!--truncate-->
O exemplo mais recente disso √© [o novo modo `unicodeSets`, habilitado usando a flag `v`](https://github.com/tc39/proposal-regexp-v-flag). Este novo modo desbloqueia suporte para _classes de caracteres estendidas_, incluindo os seguintes recursos:

- [Propriedades Unicode de strings](/features/regexp-v-flag#unicode-properties-of-strings)
- [Nota√ß√£o de conjuntos + sintaxe literal de string](/features/regexp-v-flag#set-notation)
- [Correspond√™ncia melhorada para mai√∫sculas e min√∫sculas](/features/regexp-v-flag#ignoreCase)

Este artigo explora cada um desses recursos. Mas primeiro ‚Äî veja como usar a nova flag:

```js
const re = /‚Ä¶/v;
```

A flag `v` pode ser combinada com flags de express√£o regular existentes, com uma exce√ß√£o not√°vel. A flag `v` habilita todas as boas caracter√≠sticas da flag `u`, mas com recursos e melhorias adicionais ‚Äî alguns dos quais s√£o incompat√≠veis retroativamente com a flag `u`. √â importante ressaltar que `v` √© um modo completamente separado de `u` e n√£o complementar. Por esta raz√£o, as flags `v` e `u` n√£o podem ser combinadas ‚Äî tentar usar ambas as flags na mesma express√£o resultar√° em um erro. As √∫nicas op√ß√µes v√°lidas s√£o: ou usar `u`, ou usar `v`, ou n√£o usar nem `u` nem `v`. Mas como `v` √© a op√ß√£o mais completa em recursos, a escolha √© f√°cil...

Vamos explorar a nova funcionalidade!

## Propriedades Unicode de strings

O Padr√£o Unicode atribui v√°rias propriedades e valores de propriedades a cada s√≠mbolo. Por exemplo, para obter o conjunto de s√≠mbolos usados no script grego, pesquise no banco de dados Unicode por s√≠mbolos cujo valor da propriedade `Script_Extensions` inclua `Greek`.

Os escapes de propriedades de caracteres Unicode do ES2018 tornam poss√≠vel acessar essas propriedades de caracteres Unicode nativamente em express√µes regulares do ECMAScript. Por exemplo, o padr√£o `\p{Script_Extensions=Greek}` corresponde a todo s√≠mbolo usado no script grego:

```js
const regexGreekSymbol = /\p{Script_Extensions=Greek}/u;
regexGreekSymbol.test('œÄ');
// ‚Üí true
```

Por defini√ß√£o, as propriedades de caracteres Unicode se expandem para um conjunto de pontos de c√≥digo e podem, portanto, ser transpostas como uma classe de caracteres contendo os pontos de c√≥digo correspondentes individualmente. Por exemplo, `\p{ASCII_Hex_Digit}` √© equivalente a `[0-9A-Fa-f]`: ela sempre corresponde a um √∫nico caractere Unicode/ponto de c√≥digo de cada vez. Em algumas situa√ß√µes, isso √© insuficiente:

```js
// Unicode define uma propriedade de caractere chamada ‚ÄúEmoji‚Äù.
const re = /^\p{Emoji}$/u;

// Corresponde a um emoji que consiste em apenas 1 ponto de c√≥digo:
re.test('‚öΩ'); // '\u26BD'
// ‚Üí true ‚úÖ

// Corresponde a um emoji que consiste em v√°rios pontos de c√≥digo:
re.test('üë®üèæ‚Äç‚öïÔ∏è'); // '\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F'
// ‚Üí false ‚ùå
```

No exemplo acima, a express√£o regular n√£o corresponde ao emoji üë®üèæ‚Äç‚öïÔ∏è porque ele consiste em v√°rios pontos de c√≥digo, e `Emoji` √© uma propriedade _de caractere_ Unicode.

Felizmente, o Padr√£o Unicode tamb√©m define v√°rias [propriedades de strings](https://www.unicode.org/reports/tr18/#domain_of_properties). Essas propriedades expandem para um conjunto de strings, cada uma contendo um ou mais pontos de c√≥digo. Em express√µes regulares, propriedades de strings se traduzem em um conjunto de alternativas. Para ilustrar isso, imagine uma propriedade Unicode que se aplica √†s strings `&apos;a&apos;`, `&apos;b&apos;`, `&apos;c&apos;`, `&apos;W&apos;`, `&apos;xy&apos;` e `&apos;xyz&apos;`. Essa propriedade se traduz em qualquer um dos seguintes padr√µes de express√£o regular (usando altern√¢ncia): `xyz|xy|a|b|c|W` ou `xyz|xy|[a-cW]`. (Strings mais longas primeiro, para que um prefixo como `&apos;xy&apos;` n√£o esconda uma string mais longa como `&apos;xyz&apos;`.) Diferentemente dos escapes de propriedades Unicode existentes, esse padr√£o pode corresponder a strings com v√°rios caracteres. Aqui est√° um exemplo de uma propriedade de strings em uso:

```js
const re = /^\p{RGI_Emoji}$/v;

// Corresponde a um emoji que consiste em apenas 1 ponto de c√≥digo:
re.test(&apos;‚öΩ&apos;); // &apos;\u26BD&apos;
// ‚Üí true ‚úÖ

// Corresponde a um emoji que consiste em m√∫ltiplos pontos de c√≥digo:
re.test(&apos;üë®üèæ‚Äç‚öïÔ∏è&apos;); // &apos;\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F&apos;
// ‚Üí true ‚úÖ
```

Este trecho de c√≥digo se refere √† propriedade de strings `RGI_Emoji`, que o Unicode define como "o subconjunto de todos os emojis v√°lidos (caracteres e sequ√™ncias) recomendados para interc√¢mbio geral". Com isso, agora podemos corresponder emojis independentemente do n√∫mero de pontos de c√≥digo que eles consistem internamente!

A flag `v` habilita suporte para as seguintes propriedades Unicode de strings desde o in√≠cio:

- `Basic_Emoji`
- `Emoji_Keycap_Sequence`
- `RGI_Emoji_Modifier_Sequence`
- `RGI_Emoji_Flag_Sequence`
- `RGI_Emoji_Tag_Sequence`
- `RGI_Emoji_ZWJ_Sequence`
- `RGI_Emoji`

Essa lista de propriedades suportadas pode aumentar no futuro √† medida que o Padr√£o Unicode definir propriedades adicionais de strings. Embora todas as propriedades atuais de strings sejam relacionadas a emojis, as futuras propriedades de strings podem atender a casos de uso completamente diferentes.

:::note
**Nota:** Embora as propriedades de strings atualmente estejam dispon√≠veis apenas com a nova flag `v`, [planejamos eventualmente disponibiliz√°-las no modo `u` tamb√©m](https://github.com/tc39/proposal-regexp-v-flag/issues/49).
:::

## Nota√ß√£o de conjuntos + sintaxe literal de string

Ao trabalhar com escapes `\p{‚Ä¶}` (sejam propriedades de caracteres ou as novas propriedades de strings), pode ser √∫til realizar diferen√ßa/subtra√ß√£o ou interse√ß√£o. Com a flag `v`, agora as classes de caracteres podem ser aninhadas, e essas opera√ß√µes de conjunto podem ser realizadas dentro delas, em vez de usar asser√ß√µes lookahead ou lookbehind adjacentes ou classes de caracteres longas expressando os intervalos calculados.

### Diferen√ßa/subtra√ß√£o com `--`

A sintaxe `A--B` pode ser usada para corresponder a strings _em `A`, mas n√£o em `B`_, tamb√©m conhecida como diferen√ßa/subtra√ß√£o.

Por exemplo, e se voc√™ quiser corresponder a todos os s√≠mbolos gregos, exceto a letra `œÄ`? Com a nota√ß√£o de conjuntos, resolver isso √© trivial:

```js
/[\p{Script_Extensions=Greek}--œÄ]/v.test(&apos;œÄ&apos;); // ‚Üí false
```

Ao usar `--` para diferen√ßa/subtra√ß√£o, o mecanismo de express√£o regular faz o trabalho duro para voc√™, mantendo seu c√≥digo leg√≠vel e f√°cil de manter.

E se, em vez de um √∫nico caractere, quisermos subtrair o conjunto de caracteres `Œ±`, `Œ≤` e `Œ≥`? Sem problemas ‚Äî podemos usar uma classe de caracteres aninhada e subtrair seu conte√∫do:

```js
/[\p{Script_Extensions=Greek}--[Œ±Œ≤Œ≥]]/v.test(&apos;Œ±&apos;); // ‚Üí false
/[\p{Script_Extensions=Greek}--[Œ±-Œ≥]]/v.test(&apos;Œ≤&apos;); // ‚Üí false
```

Outro exemplo √© corresponder a d√≠gitos n√£o ASCII, por exemplo, para convert√™-los em d√≠gitos ASCII mais tarde:

```js
/[\p{Decimal_Number}--[0-9]]/v.test(&apos;ëúπ&apos;); // ‚Üí true
/[\p{Decimal_Number}--[0-9]]/v.test(&apos;4&apos;); // ‚Üí false
```

A nota√ß√£o de conjuntos tamb√©m pode ser usada com as novas propriedades de strings:

```js
// Nota: üè¥ consiste em 7 pontos de c√≥digo.

/^\p{RGI_Emoji_Tag_Sequence}$/v.test(&apos;üè¥&apos;); // ‚Üí true
/^[\p{RGI_Emoji_Tag_Sequence}--\q{üè¥}]$/v.test(&apos;üè¥&apos;); // ‚Üí false
```

Este exemplo corresponde a qualquer sequ√™ncia de tags de emoji RGI _exceto_ a bandeira da Esc√≥cia. Observe o uso de `\q{‚Ä¶}`, que √© outra nova pe√ßa de sintaxe para literais de string dentro de classes de caracteres. Por exemplo, `\q{a|bc|def}` corresponde √†s strings `a`, `bc` e `def`. Sem `\q{‚Ä¶}`, n√£o seria poss√≠vel subtrair strings codificadas com v√°rios caracteres.

### Interse√ß√£o com `&&`

A sintaxe `A&&B` corresponde a strings que est√£o _tanto em `A` quanto em `B`_, tamb√©m conhecida como interse√ß√£o. Isso permite que voc√™ fa√ßa coisas como corresponder a letras gregas:

```js
const re = /[\p{Script_Extensions=Greek}&&\p{Letter}]/v;
// U+03C0 LETRA MIN√öSCULA GREGA PI
re.test(&apos;œÄ&apos;); // ‚Üí true
// U+1018A SINAL DE ZERO GREGO
re.test(&apos;êÜä&apos;); // ‚Üí false
```

Corresponder a todos os espa√ßos em branco ASCII:

```js
const re = /[\p{White_Space}&&\p{ASCII}]/v;
re.test(&apos;\n&apos;); // ‚Üí true
re.test(&apos;\u2028&apos;); // ‚Üí false
```

Ou corresponder a todos os n√∫meros mong√≥is:

```js
const re = /[\p{Script_Extensions=Mongolian}&&\p{Number}]/v;
// U+1817 D√çGITO MONGOL SETE
re.test(&apos;·†ó&apos;); // ‚Üí true
// U+1834 LETRA MONGOL CHA
re.test(&apos;·†¥&apos;); // ‚Üí false
```

### Uni√£o

Corresponder a strings que est√£o _em A ou em B_ j√° era poss√≠vel anteriormente para strings de um √∫nico caractere usando uma classe de caracteres como `[\p{Letter}\p{Number}]`. Com a flag `v`, essa funcionalidade se torna mais poderosa, pois agora pode ser combinada com propriedades de strings ou literais de string tamb√©m:

```js
const re = /^[\p{Emoji_Keycap_Sequence}\p{ASCII}\q{üáßüá™|abc}xyz0-9]$/v;

re.test(&apos;4Ô∏è‚É£&apos;); // ‚Üí true
re.test(&apos;_&apos;); // ‚Üí true
re.test(&apos;üáßüá™&apos;); // ‚Üí true
re.test(&apos;abc&apos;); // ‚Üí true
re.test(&apos;x&apos;); // ‚Üí true
re.test(&apos;4&apos;); // ‚Üí true
```

A classe de caracteres neste padr√£o combina:

- uma propriedade de strings (`\p{Emoji_Keycap_Sequence}`)
- uma propriedade de caracteres (`\p{ASCII}`)
- sintaxe literal de string para as strings com m√∫ltiplos pontos de c√≥digo `üáßüá™` e `abc`
- sintaxe cl√°ssica de classe de caracteres para caracteres solit√°rios `x`, `y` e `z`
- sintaxe cl√°ssica de classe de caracteres para o intervalo de caracteres de `0` a `9`

Outro exemplo √© corresponder todos os emojis de bandeira comumente usados, independentemente de serem codificados como um c√≥digo ISO de duas letras (`RGI_Emoji_Flag_Sequence`) ou como uma sequ√™ncia especial de tags (`RGI_Emoji_Tag_Sequence`):

```js
const reFlag = /[\p{RGI_Emoji_Flag_Sequence}\p{RGI_Emoji_Tag_Sequence}]/v;
// Uma sequ√™ncia de bandeira, composta de 2 pontos de c√≥digo (bandeira da B√©lgica):
reFlag.test(&apos;üáßüá™&apos;); // ‚Üí true
// Uma sequ√™ncia de tags, composta de 7 pontos de c√≥digo (bandeira da Inglaterra):
reFlag.test(&apos;üè¥&apos;); // ‚Üí true
// Uma sequ√™ncia de bandeira, composta de 2 pontos de c√≥digo (bandeira da Su√≠√ßa):
reFlag.test(&apos;üá®üá≠&apos;); // ‚Üí true
// Uma sequ√™ncia de tags, composta de 7 pontos de c√≥digo (bandeira do Pa√≠s de Gales):
reFlag.test(&apos;üè¥&apos;); // ‚Üí true
```

## Melhoria na correspond√™ncia insens√≠vel a mai√∫sculas e min√∫sculas

O sinalizador `u` do ES2015 sofre de [comportamento confuso na correspond√™ncia insens√≠vel a mai√∫sculas e min√∫sculas](https://github.com/tc39/proposal-regexp-v-flag/issues/30). Considere as duas express√µes regulares a seguir:

```js
const re1 = /\p{Lowercase_Letter}/giu;
const re2 = /[^\P{Lowercase_Letter}]/giu;
```

O primeiro padr√£o corresponde a todas as letras min√∫sculas. O segundo padr√£o usa `\P` em vez de `\p` para corresponder a todos os caracteres, exceto as letras min√∫sculas, mas √© ent√£o envolvido em uma classe de caracteres negada (`[^‚Ä¶]`). Ambas as express√µes regulares s√£o tornadas insens√≠veis a mai√∫sculas e min√∫sculas configurando o sinalizador `i` (`ignoreCase`).

Intuitivamente, voc√™ pode esperar que ambas as express√µes regulares se comportem da mesma maneira. Na pr√°tica, elas se comportam de forma muito diferente:

```js
const re1 = /\p{Lowercase_Letter}/giu;
const re2 = /[^\P{Lowercase_Letter}]/giu;

const string = &apos;aAbBcC4#&apos;;

string.replaceAll(re1, &apos;X&apos;);
// ‚Üí &apos;XXXXXX4#&apos;

string.replaceAll(re2, &apos;X&apos;);
// ‚Üí &apos;aAbBcC4#&apos;&apos;
```

O novo sinalizador `v` tem um comportamento menos surpreendente. Com o sinalizador `v` em vez do sinalizador `u`, ambos os padr√µes se comportam da mesma maneira:

```js
const re1 = /\p{Lowercase_Letter}/giv;
const re2 = /[^\P{Lowercase_Letter}]/giv;

const string = &apos;aAbBcC4#&apos;;

string.replaceAll(re1, &apos;X&apos;);
// ‚Üí &apos;XXXXXX4#&apos;

string.replaceAll(re2, &apos;X&apos;);
// ‚Üí &apos;XXXXXX4#&apos;
```

Mais geralmente, o sinalizador `v` torna `[^\p{X}]` ‚âç `[\P{X}]` ‚âç `\P{X}` e `[^\P{X}]` ‚âç `[\p{X}]` ‚âç `\p{X}`, independentemente de o sinalizador `i` estar configurado ou n√£o.

## Leitura adicional

[O reposit√≥rio da proposta](https://github.com/tc39/proposal-regexp-v-flag) cont√©m mais detalhes e informa√ß√µes sobre essas funcionalidades e suas decis√µes de design.

Como parte do nosso trabalho nessas funcionalidades do JavaScript, fomos al√©m de ‚Äúapenas‚Äù propor mudan√ßas na especifica√ß√£o para ECMAScript. Propusemos a defini√ß√£o de ‚Äúpropriedades de cadeias de caracteres‚Äù para [Unicode UTS#18](https://unicode.org/reports/tr18/#Notation_for_Properties_of_Strings), para que outras linguagens de programa√ß√£o possam implementar funcionalidades semelhantes de forma unificada. Tamb√©m estamos [propondo uma mudan√ßa no padr√£o HTML](https://github.com/whatwg/html/pull/7908) com o objetivo de permitir essas novas funcionalidades no atributo `pattern` tamb√©m.

## Suporte ao sinalizador `v` em RegExp

O V8 v11.0 (Chrome 110) oferece suporte experimental para essa nova funcionalidade via o sinalizador `--harmony-regexp-unicode-sets`. O V8 v12.0 (Chrome 112) tem os novos recursos habilitados por padr√£o. Babel tamb√©m suporta a transpira√ß√£o do sinalizador `v` ‚Äî [experimente os exemplos deste artigo no Babel REPL](https://babeljs.io/repl#?code_lz=MYewdgzgLgBATgUxgXhgegNoYIYFoBmAugGTEbC4AWhhaAbgNwBQTaaMAKpQJYQy8xKAVwDmSQCgEMKHACeMIWFABbJQjBRuYEfygBCVmlCRYCJSABW3FOgA6ABwDeAJQDiASQD6AUTOWAvvTMQA&presets=stage-3)! A tabela de suporte abaixo cont√©m links para problemas de rastreamento aos quais voc√™ pode se inscrever para receber atualiza√ß√µes.

<feature-support chrome="112 https://bugs.chromium.org/p/v8/issues/detail?id=11935"
                 firefox="116 https://bugzilla.mozilla.org/show_bug.cgi?id=regexp-v-flag"
                 safari="17 https://bugs.webkit.org/show_bug.cgi?id=regexp-v-flag"
                 nodejs="20"
                 babel="7.17.0 https://babeljs.io/blog/2022/02/02/7.17.0"></feature-support>
